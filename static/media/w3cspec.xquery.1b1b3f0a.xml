<!--XSLT Processor: Saxonica SAXON HE 9.6.0.7--><!--XSLT Processor: Saxonica SAXON HE 9.6.0.7--><!--  ================================================================================  --><!--  Errata applied:                                                                   --><!--  ================================================================================  --><!-- Remove the status attribute when publishing a public WD or later stage of progression --><spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" id="spec-top" w3c-doctype="rec" status="int-review"><header id="spec-header"><title>XQueryX 3.1</title><version/><w3c-designation>REC-xqueryx-31</w3c-designation><!--    <w3c-doctype>W3C Internal Draft</w3c-doctype> --><w3c-doctype>W3C Recommendation</w3c-doctype><pubdate><day>21</day><month>March</month><year>2017</year></pubdate><publoc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/2017/REC-xqueryx-31-20170321/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2017/REC-xqueryx-31-20170321/</loc>
      </publoc><!-- These altlocs URIs are computed from the concatenation of doc.public, doc.shortname, and either '.xml' or
     '-diff-from-yyyymmdd.html', where 'yyyymmdd' is the earlier version of the spec from which a diff has been produced --><altlocs><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/2017/REC-xqueryx-31-20170321/xqueryx-31.xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML</loc><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/2017/REC-xqueryx-31-20170321/xqueryx-31-diff.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Change markings relative to previous Working Draft</loc></altlocs><!-- The latestloc URI is computed from doc.latestloc --><latestloc doc="XQueryX 3.1">
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/xqueryx-31/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/xqueryx-31/</loc>
      </latestloc><!-- These prevlocs URIs are always hard-coded and are never computed from entities --><prevlocs doc="XQueryX 3.1">
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/2017/PR-xqueryx-31-20170117/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2017/PR-xqueryx-31-20170117/</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/2016/CR-xqueryx-31-20161213/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2016/CR-xqueryx-31-20161213/</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/2014/CR-xqueryx-31-20141218/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2014/CR-xqueryx-31-20141218/</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/2014/WD-xqueryx-31-20141007/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2014/WD-xqueryx-31-20141007/</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/2014/WD-xqueryx-31-20140424/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2014/WD-xqueryx-31-20140424/</loc>
      </prevlocs><latestloc-major doc="XQueryX 3">
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/xqueryx-3/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/xqueryx-3/</loc>
      </latestloc-major><latestloc-tech doc="XQueryX">
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/xqueryx/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/xqueryx/</loc>
      </latestloc-tech><prevrec doc="XQueryX">
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/2014/REC-xqueryx-30-20140408/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2014/REC-xqueryx-30-20140408/</loc>
      </prevrec><authlist><author><name>Jim Melton</name><affiliation>Oracle Corporation</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:jim.melton@oracle.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">jim.melton@oracle.com</email></author><author><name>Josh Spiegel</name><affiliation>Oracle Corporation</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:josh.spiegel@oracle.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">josh.spiegel@oracle.com</email></author></authlist><errataloc xmlns:xlink="http://www.w3.org/1999/xlink" diff="chg" href="https://www.w3.org/XML/2017/qt-errata/xqueryx-31-errata.html" xlink:type="simple"/><translationloc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/2003/03/Translations/byTechnology?technology=xqueryx-31" xlink:type="simple"/><abstract><p>This document defines an XML Syntax for <phrase diff="chg">
               <bibref ref="xquery-31"/>
            </phrase>.</p></abstract><!--* Common status section for QT specs.
    * Use is currently not required, but it simplifies things.
    * 
    * Revisions:
    * 2007-01-15 : CMSMcQ : made file, to simplify publication of Rec.
    * 2008-02-15 : JimMelton : cloned from MSM's REC-only material
                     to generalize for all stages
    *--><status id="status"><!-- ************************************************************************** --><!-- * All Status sections must start with the standard boilerplate paragraph * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>
            <emph>This section describes the status of this
         document at the time of its publication.
         Other documents may supersede this document.
         A list of current W3C publications and the latest
         revision of this technical report can be found in the
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C technical reports index</loc>
         at https://www.w3.org/TR/.</emph>
         </p><p>This document is governed by the
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" id="w3c_process_revision" href="https://www.w3.org/2017/Process-20170301/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">1 March 2017 W3C Process Document</loc>. </p><!-- ************************************************************************** --><!-- * QT publishes suites of documents, which must be described in the       * --><!--     Status section of each document within such a suite.                 * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><!-- ************************************************************************** --><!-- * There is a lot of detailed customization based on the document stage   * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>This is a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/2015/Process-20150901/#rec-publication" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Recommendation</loc> of the W3C. 
It was developed by the W3C <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/XML/Query/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Query Working Group</loc>,
which is part of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/XML/Activity" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Activity</loc>.</p><!-- ************************************************************************** --><!-- * CR documents must cite features at risk                                * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><!-- ************************************************************************** --><!-- * Every Status section must have a customized paragraph                  * --><!-- *   This entity is defined completely in the host document.              * --><!-- ************************************************************************** --><p diff="chg" at="2013-12-06">This Recommendation specifies the XML syntax for XQuery
                               version 3.1, a fully compatible extension of <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/xqueryx-30/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XQueryX version 3.0</loc>.</p><p diff="chg" at="2014-07-14">This Recommendation, dated 21 March 2017, contains changes to
                               align XQueryX 3.1 with changes to XQuery 3.1 up until the date of this publication.</p><!-- ************************************************************************** --><!-- * CR docs should, and PR docs must, have a pointer to an implementation  * --><!-- *   report.  We also want to point to the test suite.                    * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>A Test Suite has been created for this document.
Implementors are encouraged to run this test suite and report their results.
The Test Suite can be found at <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://dev.w3.org/2011/QT3-test-suite/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://dev.w3.org/2011/QT3-test-suite/</loc>. 
An <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://dev.w3.org/2011/QT3-test-suite/ReportingResults31/report.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">implementation report</loc> is available.</p><!-- ************************************************************************** --><!-- * The Status section should point to a changelog                         * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>No substantive changes have been made to this specification
since its publication as a Proposed Recommendation.</p><!-- ************************************************************************** --><!-- * The Status section must tell readers where to send comments            * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>Please report errors in this document using W3C's
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public Bugzilla system</loc>
         (instructions can be found at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/XML/2005/04/qt-bugzilla" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/XML/2005/04/qt-bugzilla</loc>).
         If access to that system is not feasible, you may send your comments
         to the W3C XSLT/XPath/XQuery public comments mailing list,
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:public-qt-comments@w3.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public-qt-comments@w3.org</loc>.
         It will be very helpful if you include the string 
         “[XQX31]”
         in the subject line of your report, whether made in Bugzilla or in email.
         Please use multiple Bugzilla entries (or, if necessary, multiple email messages)
         if you have more than one comment to make.
         Archives of the comments and responses are available at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://lists.w3.org/Archives/Public/public-qt-comments/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://lists.w3.org/Archives/Public/public-qt-comments/</loc>. </p><!-- ************************************************************************** --><!-- Status sections must state the stability (not stable, or REC) of the document --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>This document has been reviewed by W3C Members, by
software developers, and by other W3C groups and interested parties,
and is endorsed by the Director as a W3C Recommendation. 
It is a stable document and may be used as reference material or cited from
another document. 
W3C's role in making the Recommendation is to draw attention to
the specification and to promote its widespread deployment. 
This enhances the functionality and interoperability of
the Web.</p><!-- ************************************************************************** --><!-- * Finally, all Status sections must end with the appropriate IPR para    * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>This document was produced by a group operating under the
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Consortium/Patent-Policy-20040205/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">5 February 2004
  W3C Patent Policy</loc>.
  W3C maintains a 
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/2004/01/pp-impl/18797/status#disclosures" rel="disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any patent disclosures</loc>
  made in connection with the deliverables of the group; 
  that page also includes instructions for disclosing a patent.
  An individual who has actual knowledge of a patent 
  which the individual believes contains
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Essential Claim(s)</loc>
  must disclose the information in accordance with
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
  section 6 of the W3C Patent Policy</loc>. </p></status><langusage><language id="EN">English</language></langusage><revisiondesc diff="chg"><p>This is the first WD of this spec. </p><p>This is the FIrst Public Working Draft of this specification. 
         It is aligned with the XQuery grammar as published in <bibref ref="xquery-31"/>.</p></revisiondesc></header><body><div1 id="Introduction"><head>Introduction</head><!--  bug 29257 --><p diff="del">The <phrase diff="chg">XQuery 1.0 Requirements</phrase>
         states that <quote>The XML Query Language MAY have
         more than one syntax binding. One query language syntax MUST be convenient for
         humans to read and write. One query language syntax MUST be expressed in XML in
         a way that reflects the underlying structure of the query.</quote>
         </p><p>XQueryX is an XML representation of an XQuery. It was created by mapping
         the productions of the XQuery grammar into XML productions.
         The result is not particularly convenient for humans to read and write, but it
         is easy for programs to parse, and because XQueryX is represented in XML, standard
         XML tools can be used to create, interpret, or modify queries.</p><!-- 2009-01-29 JM: Add paragraph clarifying that all Notes are non-normative per Bugzilla Bug #6377 and Erratum XQX.E6 --><p>In this document, examples and material labeled as <quote>Note</quote> are provided for
           explanatory purposes and are not normative. </p><!-- 2005-10-05 JM: Add informative note clarifying that the
     XQueryX static/dynamic contexts are the same as the XQuery contexts --><note><p>Because the two syntaxes are merely different grammars that express the
           same query semantics, they share all aspects of an XQuery processing system
           except for the component that recognizes and translates the source representation
           of a query (that is, the parser). 
           The aspects that are shared include both the static context and
           the dynamic context that are defined in <phrase diff="chg">
                  <bibref ref="xquery-31"/>
               </phrase>. </p></note><p>There are several environments in which XQueryX may be useful:</p><ulist><item><p>
                  <emph>Parser Reuse.</emph> In heterogeneous environments, a
             variety of systems may be used to execute a query. One parser can generate XQueryX
             for all of these systems.</p></item><item><p>
                  <emph>Queries on Queries.</emph> Because XQueryX is represented in XML, queries
             can be queried and can be transformed into new queries. For instance, a query can
             be performed against a set of XQueryX queries to determine which queries use
             FLWOR expressions to range over a set of invoices.</p></item><item><p>
                  <emph>Generating Queries.</emph> In some XML-oriented programming
             environments, it may be more convenient to build a query in its XQueryX
             representation than in the corresponding XQuery representation, since ordinary
             XML tools can be used.</p></item><item><p>
                  <emph>Embedding Queries in XML.</emph> XQueryX can be embedded
             directly in an XML document.</p></item></ulist><p>This version of XQueryX is fully compatible with <bibref ref="xqueryx-30"/>. 
      It differs from that earlier version of the language by the addition of new XML Schema
      definitions and XSLT stylesheet templates.  All queries expressed in the syntax defined
      by <bibref ref="xqueryx-30"/> continue to be valid, with the same meaning, when processed
      by an implementation of this version of XQueryX. 
    </p><p>The most recent versions of the XQueryX XML Schema and the XQueryX XSLT stylesheet
       are available at
       <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/2017/03/XQueryX/xqueryx.xsd" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/2017/03/XQueryX/xqueryx.xsd</loc>
       and
       <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/2017/03/XQueryX/xqueryx.xsl" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/2017/03/XQueryX/xqueryx.xsl</loc>,
       respectively. </p><note><p>The locations at which the current versions of the XML Schema and XSLT stylesheet are located during development of
      this specification will vary with each Working Draft and Candidate Recommendation of the spec that is published. 
      The namespace target URI is identical to that used for <bibref ref="xqueryx-30"/>. </p></note></div1><div1 id="Mapping"><head>Mapping the XQuery Syntax</head><p>XQueryX is an XML representation of the abstract syntax found in
         Appendix A of <phrase diff="chg">
               <bibref ref="xquery-31"/>
            </phrase>. 
         The XQueryX syntax is defined by the XQueryX Schema,
         which is specified in <specref ref="Schema"/>. 
         The XQueryX semantics are defined by a stylesheet that maps
         an instance of XQueryX to an instance of XQuery;
         see <specref ref="Stylesheet"/>.</p><p>The main data structure in the XQueryX Schema is the set of types that describe
         expressions. We have chosen to model expressions using substitution groups,
         with an "expr" abstract base class and a number of intermediate abstract classes. </p><p>Consider the following productions from the abstract syntax:</p><!-- insert the grammar snippet here --><eg xml:space="preserve">
FLWORExpr          ::= InitialClause IntermediateClause* ReturnClause
InitialClause      ::= ForClause | LetClause | WindowClause
IntermediateClause ::= InitialClause | WhereClause | GroupByClause | OrderByClause | CountClause
ForClause          ::= "outer"? "for" "$" VarName TypeDeclaration? PositionalVar? "in" ExprSingle
                         ("," "$" VarName TypeDeclaration? PositionalVar? "in" ExprSingle)*
PositionalVar      ::= "at" "$" VarName
LetClause          ::= "let" "$" VarName TypeDeclaration? ":=" ExprSingle
                         ("," "$" VarName TypeDeclaration? ":=" ExprSingle)*
WhereClause        ::= "where" ExprSingle
</eg><note><p>Those productions do not represent the entire FLWOR expression, so some of the
           BNF non-terminal names are not resolved in the example abstract syntax. </p></note><p>The following XQueryX Schema definitions reflect the structure of those
         productions from that abstract syntax:</p><!-- insert schema snippet here --><eg xml:space="preserve">  
&lt;!-- The base class --&gt;
  &lt;xsd:complexType name="expr"/&gt;
  &lt;xsd:element name="expr" type="expr" abstract="true"/&gt;

  &lt;!-- Simple wrapper class --&gt;
  &lt;xsd:complexType name="exprWrapper"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="expr"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
  
  &lt;xsd:complexType name="flworExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element ref="forClause"/&gt;
            &lt;xsd:element ref="letClause"/&gt;
            &lt;xsd:element ref="windowClause"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xsd:element ref="forClause"/&gt;
              &lt;xsd:element ref="letClause"/&gt;
              &lt;xsd:element ref="windowClause"/&gt;
              &lt;xsd:element ref="countClause"/&gt;
              &lt;xsd:element ref="whereClause"/&gt;
              &lt;xsd:element ref="groupByClause"/&gt;
              &lt;xsd:element ref="orderByClause"/&gt;
            &lt;/xsd:choice&gt;
          &lt;xsd:element ref="returnClause"/&gt;
        &lt;/xsd:sequence&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="flworExpr" type="flworExpr" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="forClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="forClauseItem" minOccurs="1" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="outer" type="xsd:boolean" default="false"/&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="forClause" type="forClause"/&gt;

  &lt;xsd:complexType name="forClauseItem"&gt;
    &lt;xsd:sequence&gt;
  	  &lt;xsd:element ref="typedVariableBinding"/&gt;
	    &lt;xsd:element ref="positionalVariableBinding" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xsd:element ref="forLetClauseItemExtensions" minOccurs="0"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="forExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="forClauseItem" type="forClauseItem"/&gt;

  &lt;xsd:element name="forLetClauseItemExtensions" abstract="true"/&gt;

  &lt;xsd:complexType name="letClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="letClauseItem" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="letClause" type="letClause"/&gt;

  &lt;xsd:complexType name="letClauseItem"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="typedVariableBinding"/&gt;
          &lt;xsd:element ref="forLetClauseItemExtensions"
                       minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xsd:sequence&gt;
        &lt;xsd:element ref="forLetClauseItemExtensions"
                     minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:choice&gt;
      &lt;xsd:element name="letExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="letClauseItem" type="letClauseItem"/&gt;

  &lt;xsd:element name="whereClause" type="exprWrapper"/&gt;
</eg><p>Since XQuery uses the expression production liberally to allow
         expressions to be flexibly combined, XQueryX uses the exprWrapper type
         in embedded contexts to allow all expression types to occur.</p></div1><div1 id="Examples"><head>Examples from the XML Query Use Cases in XML Syntax</head><p>Three of following examples are based on the data and queries in the XMP
         (Experiences and Exemplars) use case in
         <phrase diff="chg">
               <bibref ref="xquery-use-cases"/>
            </phrase>,
         while a fourth example is based on the data and queries in the
         NS (Queries Using Namespaces) use case. 
         For each example, we show the English description of the query,
         the XQuery solution given in <phrase diff="chg">
               <bibref ref="xquery-use-cases"/>
            </phrase>,
         an XQueryX solution, and the XQuery that results from applying the XQueryX-to-XQuery transformation
         defined by the stylesheet in <specref ref="Stylesheet"/> to the XQueryX solution. 
         The generated XQuery is presented only as a sanity-check —
         the intent of the stylesheet is not to create the identical
         XQuery expression given in <phrase diff="chg">
               <bibref ref="xquery-use-cases"/>
            </phrase>,
         but to produce <emph>a</emph> valid
         XQuery expression with the same semantics. 
         The semantics of the XQueryX solution are determined by the semantics of the XQuery expression that
         results from that transformation.  The "correctness" of that transformation is determined by
         asking the following the question:
         Can some XQueryX processor QX process some XQueryX document D1 to produce results R1,
         after which the stylesheet is used to translate D1 into an XQuery expression E1 that,
         when processed by some XQuery processor Q, produces results R2 that are equivalent
         (under some meaningful definition of "equivalent") to results R1? </p><p>Comparison of the results of the XQueryX-to-XQuery transformation given in this document
         with the XQuery solutions in the <phrase diff="chg">
               <bibref ref="xquery-use-cases"/>
            </phrase>
         may be helpful in evaluating
         the correctness of the XQueryX solution in each example. </p><p>The XQuery Use Cases solution given for each example is provided only to assist readers of this
         document in understanding the XQueryX solution.  There is no intent to imply that this
         document specifies a "compilation" or "transformation" of XQuery syntax into XQueryX syntax. </p><p>In the following examples, note that path expressions are expanded to show their
         structure. Also, note that the prefix syntax for binary operators like "and" makes the
         precedence explicit. In general, humans find it easier to read an XML representation
         that does not expand path expressions, but it is less convenient for programmatic
         representation and manipulation.  XQueryX is designed as a language that is convenient
         for production and modification by software, and not as a convenient syntax for humans to
         read and write. </p><p>Finally, please note that white space, including new lines, have been added to
         some of the XQueryX documents and XQuery expressions for readability. 
         That additional white space is not produced by the XQueryX-to-XQuery transformation. </p><div2 id="Example1"><head>Example 1</head><p>Here is Q1 from the <phrase diff="chg">
                  <bibref ref="xquery-use-cases"/>
               </phrase>,
           use case XMP (Experiences and Exemplars): "List books published by Addison-Wesley after 1991,
           including their year and title."</p><div3 id="Example1-XQuery"><head>XQuery solution in XQuery Use Cases:</head><eg xml:space="preserve">
&lt;bib&gt;
 {
  for $b in doc("http://bstore1.example.com/bib.xml")/bib/book
  where $b/publisher = "Addison-Wesley" and $b/@year &gt; 1991
  return
    &lt;book year="{ $b/@year }"&gt;
     { $b/title }
    &lt;/book&gt;
 }
&lt;/bib&gt;
</eg></div3><div3 id="Example1-XQueryX"><head>A Solution in XQueryX:</head><eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                                http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:elementConstructor&gt;
        &lt;xqx:tagName&gt;bib&lt;/xqx:tagName&gt;
        &lt;xqx:elementContent&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;b&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:functionCallExpr&gt;
                          &lt;xqx:functionName&gt;doc&lt;/xqx:functionName&gt;
                          &lt;xqx:arguments&gt;
                            &lt;xqx:stringConstantExpr&gt;
                              &lt;xqx:value&gt;http://bstore1.example.com/bib.xml&lt;/xqx:value&gt;
                            &lt;/xqx:stringConstantExpr&gt;
                          &lt;/xqx:arguments&gt;
                        &lt;/xqx:functionCallExpr&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;bib&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;book&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:whereClause&gt;
              &lt;xqx:andOp&gt;
                &lt;xqx:firstOperand&gt;
                  &lt;xqx:equalOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;publisher&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:stringConstantExpr&gt;
                        &lt;xqx:value&gt;Addison-Wesley&lt;/xqx:value&gt;
                      &lt;/xqx:stringConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:equalOp&gt;
                &lt;/xqx:firstOperand&gt;
                &lt;xqx:secondOperand&gt;
                  &lt;xqx:greaterThanOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;year&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:integerConstantExpr&gt;
                        &lt;xqx:value&gt;1991&lt;/xqx:value&gt;
                      &lt;/xqx:integerConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:greaterThanOp&gt;
                &lt;/xqx:secondOperand&gt;
              &lt;/xqx:andOp&gt;
            &lt;/xqx:whereClause&gt;
            &lt;xqx:returnClause&gt;
              &lt;xqx:elementConstructor&gt;
                &lt;xqx:tagName&gt;book&lt;/xqx:tagName&gt;
                &lt;xqx:attributeList&gt;
                  &lt;xqx:attributeConstructor&gt;
                    &lt;xqx:attributeName&gt;year&lt;/xqx:attributeName&gt;
                    &lt;xqx:attributeValueExpr&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;year&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:attributeValueExpr&gt;
                  &lt;/xqx:attributeConstructor&gt;
                &lt;/xqx:attributeList&gt;
                &lt;xqx:elementContent&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:varRef&gt;
                          &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                        &lt;/xqx:varRef&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;title&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:elementContent&gt;
              &lt;/xqx:elementConstructor&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:elementContent&gt;
      &lt;/xqx:elementConstructor&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</eg></div3><div3 id="Example1-Transformation"><head>Transformation of XQueryX Solution into XQuery</head><p>Application of the stylesheet in <specref ref="Stylesheet"/>
             to the XQueryX solution results in:</p><eg xml:space="preserve">  
&lt;bib&gt;{
 for $b in doc("http://bstore1.example.com/bib.xml")/child::bib/child::book
 where (($b/child::publisher = "Addison-Wesley") and ($b/attribute::year &gt; 1991))
 return &lt;book year="{$b/attribute::year}"&gt;{$b/child::title}&lt;/book&gt;
}&lt;/bib&gt;
</eg></div3><div3 id="Example1-Abstract"><head>Corresponding Grammar Abstract Parse Tree</head><!-- replaced link to grammar applet per Bugzilla Bug #5323 --><p>For comparison, here is the abstract parse tree corresponding to the
             XQuery for Example 1, as produced by the XQuery grammar applets found at
             <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/2007/01/applets/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/2007/01/applets/</loc>. </p><eg xml:space="preserve">
XPath2
  QueryList
    Module
      MainModule
        Prolog
        QueryBody
          Expr
            PathExpr
              Constructor
                DirectConstructor
                  DirElemConstructor &gt;
                    LessThanOpOrTagO &lt;
                    TagQName bib
                    DirAttributeList
                    StartTagClose &gt;
                    DirElemContent
                      ElementContentChar 
                    DirElemContent
                      ElementContentChar  
                    DirElemContent
                      CommonContent
                        EnclosedExpr
                          Lbrace {
                          Expr
                            FLWORExpr
                              ForClause
                                VarName
                                  QName b
                                PathExpr
                                  FunctionCall
                                    FunctionQName doc
                                    PathExpr
                                      StringLiteral "http://bstore1.example.com/bib.xml"
                                  StepExpr
                                    AbbrevForwardStep
                                      NodeTest
                                        NameTest
                                          QName bib
                                  StepExpr
                                    AbbrevForwardStep
                                      NodeTest
                                        NameTest
                                          QName book
                              WhereClause
                                AndExpr and
                                  ComparisonExpr =
                                    PathExpr
                                      VarName
                                        QName b
                                      StepExpr
                                        AbbrevForwardStep
                                          NodeTest
                                            NameTest
                                              QName publisher
                                    PathExpr
                                      StringLiteral "Addison-Wesley"
                                  ComparisonExpr &gt;
                                    PathExpr
                                      VarName
                                        QName b
                                      StepExpr
                                        AbbrevForwardStep @
                                          NodeTest
                                            NameTest
                                              QName year
                                    PathExpr
                                      IntegerLiteral 1991
                              PathExpr
                                Constructor
                                  DirectConstructor
                                    DirElemConstructor &gt;
                                      LessThanOpOrTagO &lt;
                                      TagQName book
                                      DirAttributeList
                                        S  
                                        TagQName year
                                        ValueIndicator =
                                        DirAttributeValue
                                          OpenQuot "
                                          QuotAttrValueContent
                                            CommonContent
                                              EnclosedExpr
                                                Lbrace {
                                                Expr
                                                  PathExpr
                                                    VarName
                                                      QName b
                                                    StepExpr
                                                      AbbrevForwardStep @
                                                        NodeTest
                                                          NameTest
                                                            QName year
                                                Rbrace }
                                          CloseQuot "
                                      StartTagClose &gt;
                                      DirElemContent
                                        ElementContentChar 
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        CommonContent
                                          EnclosedExpr
                                            Lbrace {
                                            Expr
                                              PathExpr
                                                VarName
                                                  QName b
                                                StepExpr
                                                  AbbrevForwardStep
                                                    NodeTest
                                                      NameTest
                                                        QName title
                                            Rbrace }
                                      DirElemContent
                                        ElementContentChar 
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                          Rbrace }
                    DirElemContent
                      ElementContentChar 
</eg></div3></div2><div2 id="Example2"><head>Example 2</head><p>Here is Q4 from the <phrase diff="chg">
                  <bibref ref="xquery-use-cases"/>
               </phrase>,
           use case XMP (Experiences and Exemplars): "For each author in the bibliography, list the
           author's name and the titles of all books by that author, grouped inside a
           "result" element."</p><div3 id="Example2-XQuery"><head>XQuery solution in XQuery Use Cases:</head><eg xml:space="preserve">
&lt;results&gt;
  {
    let $a := doc("http://bstore1.example.com/bib/bib.xml")//author
    for $last in distinct-values($a/last),
        $first in distinct-values($a[last=$last]/first)
    order by $last, $first
    return
        &lt;result&gt;
            &lt;author&gt;
               &lt;last&gt;{ $last }&lt;/last&gt;
               &lt;first&gt;{ $first }&lt;/first&gt;
            &lt;/author&gt;
            {
                for $b in doc("http://bstore1.example.com/bib.xml")/bib/book
                where some $ba in $b/author 
                      satisfies ($ba/last = $last and $ba/first=$first)
                return $b/title
            }
        &lt;/result&gt;
  }
&lt;/results&gt; 
</eg></div3><div3 id="Example2-XQueryX"><head>A solution in XQueryX:</head><!-- insert exmpl2 here --><eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                          http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:elementConstructor&gt;
        &lt;xqx:tagName&gt;results&lt;/xqx:tagName&gt;
        &lt;xqx:elementContent&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:letClause&gt;
              &lt;xqx:letClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;a&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:letExpr&gt;
                 &lt;xqx:pathExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:filterExpr&gt;
                       &lt;xqx:functionCallExpr&gt;
                         &lt;xqx:functionName&gt;doc&lt;/xqx:functionName&gt;
                         &lt;xqx:arguments&gt;
                           &lt;xqx:stringConstantExpr&gt;
                             &lt;xqx:value&gt;http://bstore1.example.com/bib.xml&lt;/xqx:value&gt;
                           &lt;/xqx:stringConstantExpr&gt;
                         &lt;/xqx:arguments&gt;
                       &lt;/xqx:functionCallExpr&gt;
                     &lt;/xqx:filterExpr&gt;
                   &lt;/xqx:stepExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                     &lt;xqx:anyKindTest/&gt;
                   &lt;/xqx:stepExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                     &lt;xqx:nameTest&gt;author&lt;/xqx:nameTest&gt;
                   &lt;/xqx:stepExpr&gt;
                 &lt;/xqx:pathExpr&gt;
                &lt;/xqx:letExpr&gt;
              &lt;/xqx:letClauseItem&gt;
            &lt;/xqx:letClause&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;last&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:functionCallExpr&gt;
                    &lt;xqx:functionName&gt;distinct-values&lt;/xqx:functionName&gt;
                    &lt;xqx:arguments&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;a&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;last&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:arguments&gt;
                  &lt;/xqx:functionCallExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;first&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:functionCallExpr&gt;
                    &lt;xqx:functionName&gt;distinct-values&lt;/xqx:functionName&gt;
                    &lt;xqx:arguments&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;a&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                          &lt;xqx:predicates&gt;
                            &lt;xqx:equalOp&gt;
                              &lt;xqx:firstOperand&gt;
                                &lt;xqx:pathExpr&gt;
                                  &lt;xqx:stepExpr&gt;
                                    &lt;xqx:filterExpr&gt;
                                      &lt;xqx:contextItemExpr/&gt;
                                    &lt;/xqx:filterExpr&gt;
                                  &lt;/xqx:stepExpr&gt;
                                  &lt;xqx:stepExpr&gt;
                                    &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                    &lt;xqx:nameTest&gt;last&lt;/xqx:nameTest&gt;
                                  &lt;/xqx:stepExpr&gt;
                                &lt;/xqx:pathExpr&gt;
                              &lt;/xqx:firstOperand&gt;
                              &lt;xqx:secondOperand&gt;
                                &lt;xqx:varRef&gt;
                                  &lt;xqx:name&gt;last&lt;/xqx:name&gt;
                                &lt;/xqx:varRef&gt;
                              &lt;/xqx:secondOperand&gt;
                            &lt;/xqx:equalOp&gt;
                          &lt;/xqx:predicates&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;first&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:arguments&gt;
                  &lt;/xqx:functionCallExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:orderByClause&gt;
              &lt;xqx:orderBySpec&gt;
                &lt;xqx:orderByExpr&gt;
                  &lt;xqx:varRef&gt;
                    &lt;xqx:name&gt;last&lt;/xqx:name&gt;
                  &lt;/xqx:varRef&gt;
                &lt;/xqx:orderByExpr&gt;
              &lt;/xqx:orderBySpec&gt;
              &lt;xqx:orderBySpec&gt;
                &lt;xqx:orderByExpr&gt;
                  &lt;xqx:varRef&gt;
                    &lt;xqx:name&gt;first&lt;/xqx:name&gt;
                  &lt;/xqx:varRef&gt;
                &lt;/xqx:orderByExpr&gt;
              &lt;/xqx:orderBySpec&gt;
            &lt;/xqx:orderByClause&gt;
            &lt;xqx:returnClause&gt;
              &lt;xqx:elementConstructor&gt;
                &lt;xqx:tagName&gt;result&lt;/xqx:tagName&gt;
                &lt;xqx:elementContent&gt;
                  &lt;xqx:elementConstructor&gt;
                    &lt;xqx:tagName&gt;author&lt;/xqx:tagName&gt;
                    &lt;xqx:elementContent&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;last&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;last&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;first&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;first&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                    &lt;/xqx:elementContent&gt;
                  &lt;/xqx:elementConstructor&gt;
                    &lt;xqx:flworExpr&gt;
                      &lt;xqx:forClause&gt;
                        &lt;xqx:forClauseItem&gt;
                          &lt;xqx:typedVariableBinding&gt;
                            &lt;xqx:varName&gt;b&lt;/xqx:varName&gt;
                          &lt;/xqx:typedVariableBinding&gt;
                          &lt;xqx:forExpr&gt;
                            &lt;xqx:pathExpr&gt;
                              &lt;xqx:stepExpr&gt;
                                &lt;xqx:filterExpr&gt;
                                  &lt;xqx:functionCallExpr&gt;
                                    &lt;xqx:functionName&gt;doc&lt;/xqx:functionName&gt;
                                    &lt;xqx:arguments&gt;
                                      &lt;xqx:stringConstantExpr&gt;
                                        &lt;xqx:value&gt;http://bstore1.example.com/bib.xml&lt;/xqx:value&gt;
                                      &lt;/xqx:stringConstantExpr&gt;
                                    &lt;/xqx:arguments&gt;
                                  &lt;/xqx:functionCallExpr&gt;
                                &lt;/xqx:filterExpr&gt;
                              &lt;/xqx:stepExpr&gt;
                              &lt;xqx:stepExpr&gt;
                                &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                &lt;xqx:nameTest&gt;bib&lt;/xqx:nameTest&gt;
                              &lt;/xqx:stepExpr&gt;
                              &lt;xqx:stepExpr&gt;
                                &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                &lt;xqx:nameTest&gt;book&lt;/xqx:nameTest&gt;
                              &lt;/xqx:stepExpr&gt;
                            &lt;/xqx:pathExpr&gt;
                          &lt;/xqx:forExpr&gt;
                        &lt;/xqx:forClauseItem&gt;
                      &lt;/xqx:forClause&gt;
                      &lt;xqx:whereClause&gt;
                        &lt;xqx:quantifiedExpr&gt;
                          &lt;xqx:quantifier&gt;some&lt;/xqx:quantifier&gt;
                          &lt;xqx:quantifiedExprInClause&gt;
                            &lt;xqx:typedVariableBinding&gt;
                              &lt;xqx:varName&gt;ba&lt;/xqx:varName&gt;
                            &lt;/xqx:typedVariableBinding&gt;
                            &lt;xqx:sourceExpr&gt;
                              &lt;xqx:pathExpr&gt;
                                &lt;xqx:stepExpr&gt;
                                  &lt;xqx:filterExpr&gt;
                                    &lt;xqx:varRef&gt;
                                      &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                                    &lt;/xqx:varRef&gt;
                                  &lt;/xqx:filterExpr&gt;
                                &lt;/xqx:stepExpr&gt;
                                &lt;xqx:stepExpr&gt;
                                  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                  &lt;xqx:nameTest&gt;author&lt;/xqx:nameTest&gt;
                                &lt;/xqx:stepExpr&gt;
                              &lt;/xqx:pathExpr&gt;
                            &lt;/xqx:sourceExpr&gt;
                          &lt;/xqx:quantifiedExprInClause&gt;
                          &lt;xqx:predicateExpr&gt;
                            &lt;xqx:andOp&gt;
                              &lt;xqx:firstOperand&gt;
                                &lt;xqx:equalOp&gt;
                                  &lt;xqx:firstOperand&gt;
                                    &lt;xqx:pathExpr&gt;
                                      &lt;xqx:stepExpr&gt;
                                        &lt;xqx:filterExpr&gt;
                                          &lt;xqx:varRef&gt;
                                            &lt;xqx:name&gt;ba&lt;/xqx:name&gt;
                                          &lt;/xqx:varRef&gt;
                                        &lt;/xqx:filterExpr&gt;
                                      &lt;/xqx:stepExpr&gt;
                                      &lt;xqx:stepExpr&gt;
                                        &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                        &lt;xqx:nameTest&gt;last&lt;/xqx:nameTest&gt;
                                      &lt;/xqx:stepExpr&gt;
                                    &lt;/xqx:pathExpr&gt;
                                  &lt;/xqx:firstOperand&gt;
                                  &lt;xqx:secondOperand&gt;
                                    &lt;xqx:varRef&gt;
                                      &lt;xqx:name&gt;last&lt;/xqx:name&gt;
                                    &lt;/xqx:varRef&gt;
                                  &lt;/xqx:secondOperand&gt;
                                &lt;/xqx:equalOp&gt;
                              &lt;/xqx:firstOperand&gt;
                              &lt;xqx:secondOperand&gt;
                                &lt;xqx:equalOp&gt;
                                  &lt;xqx:firstOperand&gt;
                                    &lt;xqx:pathExpr&gt;
                                      &lt;xqx:stepExpr&gt;
                                        &lt;xqx:filterExpr&gt;
                                          &lt;xqx:varRef&gt;
                                            &lt;xqx:name&gt;ba&lt;/xqx:name&gt;
                                          &lt;/xqx:varRef&gt;
                                        &lt;/xqx:filterExpr&gt;
                                      &lt;/xqx:stepExpr&gt;
                                      &lt;xqx:stepExpr&gt;
                                        &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                        &lt;xqx:nameTest&gt;first&lt;/xqx:nameTest&gt;
                                      &lt;/xqx:stepExpr&gt;
                                    &lt;/xqx:pathExpr&gt;
                                  &lt;/xqx:firstOperand&gt;
                                  &lt;xqx:secondOperand&gt;
                                    &lt;xqx:varRef&gt;
                                      &lt;xqx:name&gt;first&lt;/xqx:name&gt;
                                    &lt;/xqx:varRef&gt;
                                  &lt;/xqx:secondOperand&gt;
                                &lt;/xqx:equalOp&gt;
                              &lt;/xqx:secondOperand&gt;
                            &lt;/xqx:andOp&gt;
                          &lt;/xqx:predicateExpr&gt;
                        &lt;/xqx:quantifiedExpr&gt;
                      &lt;/xqx:whereClause&gt;
                      &lt;xqx:returnClause&gt;
                        &lt;xqx:pathExpr&gt;
                          &lt;xqx:stepExpr&gt;
                            &lt;xqx:filterExpr&gt;
                              &lt;xqx:varRef&gt;
                                &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                              &lt;/xqx:varRef&gt;
                            &lt;/xqx:filterExpr&gt;
                          &lt;/xqx:stepExpr&gt;
                          &lt;xqx:stepExpr&gt;
                            &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                            &lt;xqx:nameTest&gt;title&lt;/xqx:nameTest&gt;
                          &lt;/xqx:stepExpr&gt;
                        &lt;/xqx:pathExpr&gt;
                      &lt;/xqx:returnClause&gt;
                    &lt;/xqx:flworExpr&gt;
                &lt;/xqx:elementContent&gt;
              &lt;/xqx:elementConstructor&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:elementContent&gt;
      &lt;/xqx:elementConstructor&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</eg></div3><div3 id="Example2-Transformation"><head>Transformation of XQueryX Solution into XQuery</head><p>Application of the stylesheet in <specref ref="Stylesheet"/>
            to the XQueryX solution results in:</p><eg xml:space="preserve">  
&lt;results&gt;{
 let $a:=doc("http://bstore1.example.com/bib.xml")/descendant-or-self::node()/child::author
 for $last in distinct-values($a/child::last), $first in distinct-values($a[(./child::last = $last)]/child::first)
 order by $last , $first 
 return &lt;result&gt;&lt;author&gt;&lt;last&gt;{$last}&lt;/last&gt;&lt;first&gt;{$first}&lt;/first&gt;&lt;/author&gt;{
 for $b in doc("http://bstore1.example.com/bib.xml")/child::bib/child::book
 where (some $ba in $b/child::author satisfies (($ba/child::last = $last) and ($ba/child::first = $first)))
 return $b/child::title
}&lt;/result&gt;
}&lt;/results&gt;
</eg></div3></div2><div2 id="Example3"><head>Example 3</head><p>Here is Q7 from the <phrase diff="chg">
                  <bibref ref="xquery-use-cases"/>
               </phrase>,
           use case XMP (Experiences and Exemplars): "List the titles and years of all books published by
           Addison-Wesley after 1991, in alphabetic order."</p><div3 id="Example3-XQuery"><head>XQuery solution in XQuery Use Cases:</head><eg xml:space="preserve">
&lt;bib&gt;
  {
    for $b in doc("http://bstore1.example.com/bib.xml")//book
    where $b/publisher = "Addison-Wesley" and $b/@year &gt; 1991
    order by $b/title
    return
        &lt;book&gt;
            { $b/@year }
            { $b/title }
        &lt;/book&gt;
  }
&lt;/bib&gt; 
</eg></div3><div3 id="Example3-XQueryX"><head>A solution in XQueryX:</head><!-- insert exmpl3 here --><eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                                http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:elementConstructor&gt;
        &lt;xqx:tagName&gt;bib&lt;/xqx:tagName&gt;
        &lt;xqx:elementContent&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;b&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:functionCallExpr&gt;
                          &lt;xqx:functionName&gt;doc&lt;/xqx:functionName&gt;
                          &lt;xqx:arguments&gt;
                            &lt;xqx:stringConstantExpr&gt;
                              &lt;xqx:value&gt;http://bstore1.example.com/bib.xml&lt;/xqx:value&gt;
                            &lt;/xqx:stringConstantExpr&gt;
                          &lt;/xqx:arguments&gt;
                        &lt;/xqx:functionCallExpr&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:anyKindTest/&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;book&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:whereClause&gt;
              &lt;xqx:andOp&gt;
                &lt;xqx:firstOperand&gt;
                  &lt;xqx:equalOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;publisher&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:stringConstantExpr&gt;
                        &lt;xqx:value&gt;Addison-Wesley&lt;/xqx:value&gt;
                      &lt;/xqx:stringConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:equalOp&gt;
                &lt;/xqx:firstOperand&gt;
                &lt;xqx:secondOperand&gt;
                  &lt;xqx:greaterThanOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;year&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:integerConstantExpr&gt;
                        &lt;xqx:value&gt;1991&lt;/xqx:value&gt;
                      &lt;/xqx:integerConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:greaterThanOp&gt;
                &lt;/xqx:secondOperand&gt;
              &lt;/xqx:andOp&gt;
            &lt;/xqx:whereClause&gt;
            &lt;xqx:orderByClause&gt;
              &lt;xqx:orderBySpec&gt;
                &lt;xqx:orderByExpr&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:varRef&gt;
                          &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                        &lt;/xqx:varRef&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;title&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:orderByExpr&gt;
              &lt;/xqx:orderBySpec&gt;
            &lt;/xqx:orderByClause&gt;
            &lt;xqx:returnClause&gt;
             &lt;xqx:elementConstructor&gt;
               &lt;xqx:tagName&gt;book&lt;/xqx:tagName&gt;
               &lt;xqx:elementContent&gt;
                 &lt;xqx:pathExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:filterExpr&gt;
                       &lt;xqx:varRef&gt;
                         &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                       &lt;/xqx:varRef&gt;
                     &lt;/xqx:filterExpr&gt;
                   &lt;/xqx:stepExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                     &lt;xqx:nameTest&gt;year&lt;/xqx:nameTest&gt;
                   &lt;/xqx:stepExpr&gt;
                 &lt;/xqx:pathExpr&gt;
                 &lt;xqx:pathExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:filterExpr&gt;
                       &lt;xqx:varRef&gt;
                         &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                       &lt;/xqx:varRef&gt;
                     &lt;/xqx:filterExpr&gt;
                   &lt;/xqx:stepExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                     &lt;xqx:nameTest&gt;title&lt;/xqx:nameTest&gt;
                   &lt;/xqx:stepExpr&gt;
                 &lt;/xqx:pathExpr&gt;
               &lt;/xqx:elementContent&gt;
             &lt;/xqx:elementConstructor&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:elementContent&gt;
      &lt;/xqx:elementConstructor&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</eg></div3><div3 id="Example3-Transformation"><head>Transformation of XQueryX Solution into XQuery</head><p>Application of the stylesheet in <specref ref="Stylesheet"/> to the XQueryX solution
             results in:</p><eg xml:space="preserve">  
&lt;bib&gt;{
 for $b in doc("http://bstore1.example.com/bib.xml")/descendant-or-self::node()/child::book
 where (($b/child::publisher = "Addison-Wesley") and ($b/attribute::year &gt; 1991))
 order by $b/child::title 
 return &lt;book&gt;{$b/attribute::year}{$b/child::title}&lt;/book&gt;
}&lt;/bib&gt;
</eg></div3></div2><div2 id="Example4"><head>Example 4</head><p>Here is Q8 from the <phrase diff="chg">
                  <bibref ref="xquery-use-cases"/>
               </phrase>,
           use case NS (Queries Using Namespaces):
           "Select all traders (either seller or high bidder) without negative comments."</p><div3 id="Example4-XQuery"><head>XQuery solution in XQuery Use Cases:</head><eg xml:space="preserve">
declare namespace ma = "http://www.example.com/AuctionWatch";
&lt;Q8 xmlns:ma="http://www.example.com/AuctionWatch"
    xmlns:eachbay="http://www.example.com/auctioneers#eachbay" 
    xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
  {
    for $s in doc("auction.xml")//ma:Trading_Partners/(ma:Seller | ma:High_Bidder)
    where $s/*:NegativeComments = 0
    return $s
  }
&lt;/Q8&gt;
</eg></div3><div3 id="Example4-XQueryX"><head>A solution in XQueryX:</head><!-- insert exmpl4 here --><eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;!--  ================================================================================  --&gt;
&lt;!--  Errata applied:                                                                   --&gt;
&lt;!--    XQX.E2 - Editorial (Bugzilla Bug 4963)                                          --&gt;
&lt;!--  ================================================================================  --&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                          http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:prolog&gt;
      &lt;xqx:namespaceDecl&gt;
        &lt;xqx:prefix&gt;ma&lt;/xqx:prefix&gt;
        &lt;xqx:uri&gt;http://www.example.com/AuctionWatch&lt;/xqx:uri&gt;
      &lt;/xqx:namespaceDecl&gt;
    &lt;/xqx:prolog&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:elementConstructor&gt;
        &lt;xqx:tagName&gt;Q8&lt;/xqx:tagName&gt;
        &lt;xqx:attributeList&gt;
          &lt;xqx:namespaceDeclaration&gt;
            &lt;xqx:prefix&gt;ma&lt;/xqx:prefix&gt;
            &lt;xqx:uri&gt;http://www.example.com/AuctionWatch&lt;/xqx:uri&gt;
          &lt;/xqx:namespaceDeclaration&gt;
          &lt;xqx:namespaceDeclaration&gt;
            &lt;xqx:prefix&gt;eachbay&lt;/xqx:prefix&gt;
            &lt;xqx:uri&gt;http://www.example.com/auctioneers#eachbay&lt;/xqx:uri&gt;
          &lt;/xqx:namespaceDeclaration&gt;
          &lt;xqx:namespaceDeclaration&gt;
            &lt;xqx:prefix&gt;xlink&lt;/xqx:prefix&gt;
            &lt;xqx:uri&gt;http://www.w3.org/1999/xlink&lt;/xqx:uri&gt;
          &lt;/xqx:namespaceDeclaration&gt;
        &lt;/xqx:attributeList&gt;
        &lt;xqx:elementContent&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;s&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:functionCallExpr&gt;
                          &lt;xqx:functionName xqx:prefix="fn"&gt;doc&lt;/xqx:functionName&gt;
                          &lt;xqx:arguments&gt;
                            &lt;xqx:stringConstantExpr&gt;
                              &lt;xqx:value&gt;auction.xml&lt;/xqx:value&gt;
                            &lt;/xqx:stringConstantExpr&gt;
                          &lt;/xqx:arguments&gt;
                        &lt;/xqx:functionCallExpr&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:anyKindTest/&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest xqx:prefix="ma"&gt;Trading_Partners&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:sequenceExpr&gt;
                          &lt;xqx:unionOp&gt;
                            &lt;xqx:firstOperand&gt;
                              &lt;xqx:pathExpr&gt;
                                &lt;xqx:stepExpr&gt;
                                  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                  &lt;xqx:nameTest xqx:prefix="ma"&gt;Seller&lt;/xqx:nameTest&gt;
                                &lt;/xqx:stepExpr&gt;
                              &lt;/xqx:pathExpr&gt;
                            &lt;/xqx:firstOperand&gt;
                            &lt;xqx:secondOperand&gt;
                              &lt;xqx:pathExpr&gt;
                                &lt;xqx:stepExpr&gt;
                                  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                  &lt;xqx:nameTest xqx:prefix="ma"&gt;High_Bidder&lt;/xqx:nameTest&gt;
                                &lt;/xqx:stepExpr&gt;
                              &lt;/xqx:pathExpr&gt;
                            &lt;/xqx:secondOperand&gt;
                          &lt;/xqx:unionOp&gt;
                        &lt;/xqx:sequenceExpr&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:whereClause&gt;
              &lt;xqx:equalOp&gt;
                &lt;xqx:firstOperand&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:varRef&gt;
                          &lt;xqx:name&gt;s&lt;/xqx:name&gt;
                        &lt;/xqx:varRef&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:Wildcard&gt;
                        &lt;xqx:star/&gt;
                        &lt;xqx:NCName&gt;NegativeComments&lt;/xqx:NCName&gt;
                      &lt;/xqx:Wildcard&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:firstOperand&gt;
                &lt;xqx:secondOperand&gt;
                  &lt;xqx:integerConstantExpr&gt;
                    &lt;xqx:value&gt;0&lt;/xqx:value&gt;
                  &lt;/xqx:integerConstantExpr&gt;
                &lt;/xqx:secondOperand&gt;
              &lt;/xqx:equalOp&gt;
            &lt;/xqx:whereClause&gt;
            &lt;xqx:returnClause&gt;
              &lt;xqx:varRef&gt;
                &lt;xqx:name&gt;s&lt;/xqx:name&gt;
              &lt;/xqx:varRef&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:elementContent&gt;
      &lt;/xqx:elementConstructor&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</eg></div3><div3 id="Example4-Transformation"><head>Transformation of XQueryX Solution into XQuery</head><p>Application of the stylesheet in <specref ref="Stylesheet"/>
             to the XQueryX solution results in:</p><eg xml:space="preserve">  
declare namespace ma="http://www.example.com/AuctionWatch";
&lt;Q8 xmlns:ma="http://www.example.com/AuctionWatch"
    xmlns:eachbay="http://www.example.com/auctioneers#eachbay"
    xmlns:xlink="http://www.w3.org/1999/xlink"&gt;{
 for $s in fn:doc("auction.xml")/descendant-or-self::node()/
                                 child::ma:Trading_Partners/
                                 ((child::ma:Seller union child::ma:High_Bidder))
 where ($s/child::*:NegativeComments = 0)
 return $s
}&lt;/Q8&gt;
</eg></div3></div2></div1><div1 id="Schema"><head>An XML Schema for the XQuery XML Syntax</head><p>Here is the XML Schema against which XQueryX documents must be valid.</p><eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;!--  ================================================================================  --&gt;
&lt;!--  NOTES TO READERS OF THIS SCHEMA:                                                  --&gt;
&lt;!--  The default value for both minOccurs and maxOccurs is "1".                        --&gt;
&lt;!--  The XQueryX schema has been designed to provide the ability to extend definitions --&gt;
&lt;!--    of top-level elements in extensions such as Full-Text and the Update Facility.  --&gt;
&lt;!--    The nature of the modification is to define named complex types and redefine    --&gt;
&lt;!--    those top-level elements in terms of the named complex types.                   --&gt;
&lt;!--  ================================================================================  --&gt;
&lt;!--  Changes from Recommendation (XQueryX 3.0):                                        --&gt;
&lt;!--  ================================================================================  --&gt;
&lt;!--  Errata applied:                                                                   --&gt;
&lt;!--  ================================================================================  --&gt;
&lt;!--  Modifications:                                                                    --&gt;
&lt;!--    JM/2014-07-11 : Added support for anyMapText and typedMapTest                   --&gt;
&lt;!--    JM/2014-07-11 : Added support for anyArrayText and typedArrayTest               --&gt;
&lt;!--    JM/2014-07-13 : Added support for new alternatives in stepExpr                  --&gt;
&lt;!--    JM/2014-07-13 : Added support for lookup (formerly mapLookup) and arrowPostfix  --&gt;
&lt;!--    JM/2014-07-13 : Added support for unaryLookup (formerly unaryMapLookup)         --&gt;
&lt;!--    JM/2014-07-13 : Added support for new alternatives in filterExpr                --&gt;
&lt;!--    JM/2014-07-13 : Added support for mapConstructor and arrayConstructor           --&gt;
&lt;!--    JM/2014-08-28 : Fixed [unary]Lookup replacing stringLiteral w/integerLiteral    --&gt;
&lt;!--    JM/2015-01-21 : Replaced arrowPostfix with arrowExpr per bug 27537              --&gt;
&lt;!--    JS/2015-11-05 : Added support for stringConstructor and optional enclosed expr  --&gt;
&lt;!--    JS/2016-09-23 : Bug 29823 - remove duplicate integerLiteral and variableRef     --&gt;
&lt;!--  ================================================================================  --&gt;

&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            xmlns="http://www.w3.org/2005/XQueryX"
            targetNamespace="http://www.w3.org/2005/XQueryX"
            elementFormDefault="qualified" attributeFormDefault="qualified"&gt;


&lt;!-- A few helper declarations                                                          --&gt;
  &lt;xsd:complexType name="emptyContent"/&gt;

  &lt;xsd:element name="NCName" type="xsd:NCName"/&gt;

  &lt;xsd:complexType name="QName"&gt;
    &lt;xsd:simpleContent&gt;
      &lt;xsd:extension base="xsd:NCName"&gt;
        &lt;xsd:attribute name="prefix" type="xsd:NCName" use="optional"/&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:simpleContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="EQName"&gt;
    &lt;xsd:simpleContent&gt;
      &lt;xsd:extension base="xsd:NCName"&gt;
        &lt;xsd:attribute name="prefix" type="xsd:NCName" use="optional"/&gt;
        &lt;xsd:attribute name="URI" type="xsd:string" use="optional"/&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:simpleContent&gt;
  &lt;/xsd:complexType&gt;

&lt;!-- The base expression class                                                          --&gt;
  &lt;xsd:complexType name="expr"/&gt;

  &lt;xsd:element name="expr" type="expr" abstract="true"/&gt;


&lt;!-- A list of expressions                                                              --&gt;
  &lt;xsd:complexType name="exprList"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="expr" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

&lt;!-- A list of expressions or placeholders                                              --&gt;
  &lt;xsd:complexType name="exprOrPlaceholderList"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
        &lt;xsd:element ref="expr"/&gt;
        &lt;xsd:element name="argumentPlaceholder" type="emptyContent"/&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

&lt;!-- A type to be used by elements that comprise an optional expr                       --&gt;
  &lt;xsd:complexType name="exprWrapperOptional"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="expr" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

&lt;!-- Simple wrapper class                                                               --&gt;
  &lt;xsd:complexType name="exprWrapper"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="expr"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

&lt;!-- A list of literals                                                                 --&gt;
  &lt;xsd:complexType name="literalList"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="constantExpr" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

&lt;!-- constant expressions. We have 4 different subclasses for this                      --&gt;
  &lt;xsd:complexType name="constantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:anyType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="constantExpr" type="constantExpr" abstract="true"
               substitutionGroup="expr"/&gt;


  &lt;xsd:complexType name="integerConstantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="constantExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:integer"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="integerConstantExpr" type="integerConstantExpr"
               substitutionGroup="constantExpr"/&gt;


  &lt;xsd:complexType name="decimalConstantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="constantExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:decimal"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="decimalConstantExpr" type="decimalConstantExpr"
               substitutionGroup="constantExpr"/&gt;


  &lt;xsd:complexType name="doubleConstantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="constantExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:double"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="doubleConstantExpr" type="doubleConstantExpr"
               substitutionGroup="constantExpr"/&gt;


  &lt;xsd:complexType name="stringConstantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="constantExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:string"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="stringConstantExpr" type="stringConstantExpr"
               substitutionGroup="constantExpr"/&gt;


&lt;!-- Variables                                                                          --&gt;
  &lt;xsd:complexType name="varRef"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="name" type="EQName"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="varRef" type="varRef" substitutionGroup="expr"/&gt;


&lt;!-- root and context-item expressions                                                  --&gt;
&lt;!-- rootExpr deleted per Bugzilla Bug #2523                                            --&gt;
  &lt;xsd:complexType name="contextItemExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"/&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="contextItemExpr" type="contextItemExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- Pragmas and extension expressions                                                  --&gt;
&lt;!--   2010-01-01, JM replaced pragmaContents elem def'n with one that has a pattern    --&gt;
  &lt;xsd:complexType name="pragma"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="pragmaName" type="EQName"/&gt;
      &lt;xsd:element name="pragmaContents"&gt;
        &lt;xsd:simpleType&gt;
          &lt;xsd:restriction base="xsd:string"&gt;
            &lt;xsd:pattern value="(([^#]|#+[^\)#])*#*)"/&gt;
          &lt;/xsd:restriction&gt;
        &lt;/xsd:simpleType&gt;
      &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="pragma" type="pragma"/&gt;


  &lt;xsd:complexType name="extensionExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="pragma" maxOccurs="unbounded"/&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="extensionExpr" type="extensionExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- Simple map expressions                                                             --&gt;
  &lt;xsd:complexType name="simpleMapExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence minOccurs="2" maxOccurs="unbounded"&gt;
          &lt;xsd:element ref="pathExpr"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="simpleMapExpr" type="simpleMapExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- Function call expressions                                                          --&gt;
  &lt;xsd:complexType name="functionCallExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="functionName" type="EQName"/&gt;
          &lt;xsd:element name="arguments" type="exprOrPlaceholderList" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="functionCallExpr" type="functionCallExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- Constructor functions                                                              --&gt;
  &lt;xsd:complexType name="constructorFunctionExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="typeName" type="EQName"/&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="constructorFunctionExpr" type="constructorFunctionExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- Sequence expressions                                                               --&gt;
  &lt;xsd:complexType name="sequenceExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="expr" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="sequenceExpr" type="sequenceExpr" substitutionGroup="expr"/&gt;


  &lt;xsd:complexType name="rangeSequenceExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="startExpr" type="exprWrapper"/&gt;
          &lt;xsd:element name="endExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="rangeSequenceExpr" type="rangeSequenceExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- Builtin operator expressions                                                       --&gt;
  &lt;xsd:complexType name="operatorExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"/&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;


  &lt;xsd:complexType name="unaryOperatorExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="operatorExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="operand" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;


  &lt;xsd:complexType name="binaryOperatorExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="operatorExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="firstOperand" type="exprWrapper"/&gt;
          &lt;xsd:element name="secondOperand" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;


&lt;!-- General operator expressions --&gt;
  &lt;xsd:element name="operatorExpr" type="operatorExpr"
               abstract="true" substitutionGroup="expr"/&gt;

&lt;!-- Arithmetic operator expressions --&gt;
  &lt;xsd:element name="arithmeticOp" type="operatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="addOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="subtractOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="multiplyOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="divOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="idivOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="modOp" type="binaryOperatorExpr"
               substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="unaryMinusOp" type="unaryOperatorExpr"
               substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="unaryPlusOp" type="unaryOperatorExpr"
               substitutionGroup="arithmeticOp"/&gt;

&lt;!-- String operator expressions --&gt;
  &lt;xsd:element name="stringOp" type="operatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="stringConcatenateOp" type="binaryOperatorExpr"
               substitutionGroup="stringOp"/&gt;

&lt;!-- Comparison operator expressions --&gt;
  &lt;xsd:element name="comparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/&gt;

&lt;!-- Value comparison operator expressions --&gt;
  &lt;xsd:element name="valueComparisonOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="eqOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="neOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="gtOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="geOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="ltOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="leOp" type="binaryOperatorExpr"
               substitutionGroup="valueComparisonOp"/&gt;

&lt;!-- General comparison operator expressions --&gt;
  &lt;xsd:element name="generalComparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="equalOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="notEqualOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="lessThanOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="lessThanOrEqualOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="greaterThanOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="greaterThanOrEqualOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/&gt;

&lt;!-- Node comparison operator expressions --&gt;
  &lt;xsd:element name="nodeComparisonOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="isOp" type="binaryOperatorExpr"
               substitutionGroup="nodeComparisonOp"/&gt;

&lt;!-- Order comparison operator expressions --&gt;
  &lt;xsd:element name="orderComparisonOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="nodeBeforeOp" type="binaryOperatorExpr"
               substitutionGroup="orderComparisonOp"/&gt;

  &lt;xsd:element name="nodeAfterOp" type="binaryOperatorExpr"
               substitutionGroup="orderComparisonOp"/&gt;

&lt;!-- Logical operator expressions --&gt;
  &lt;xsd:element name="logicalOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="andOp" type="binaryOperatorExpr"
               substitutionGroup="logicalOp"/&gt;

  &lt;xsd:element name="orOp" type="binaryOperatorExpr"
               substitutionGroup="logicalOp"/&gt;

  &lt;xsd:element name="setOp" type="binaryOperatorExpr"
               abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="unionOp" type="binaryOperatorExpr"
               substitutionGroup="setOp"/&gt;

  &lt;xsd:element name="intersectOp" type="binaryOperatorExpr"
               substitutionGroup="setOp"/&gt;

  &lt;xsd:element name="exceptOp" type="binaryOperatorExpr"
               substitutionGroup="setOp"/&gt;


&lt;!-- Basic typenames                                                                    --&gt;
&lt;!-- By changing the type attribute from QName to EQName, this is now atomicOrUnionType --&gt;
&lt;!--   However, for backwards compatibility w/XQueryX 1.0, the name had to stay the same--&gt;
  &lt;xsd:element name="atomicType" type="EQName" substitutionGroup="itemType"/&gt;


&lt;!-- Used in castable expression and cast expression                                    --&gt;
  &lt;xsd:complexType name="singleType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="atomicType"/&gt;
      &lt;xsd:element name="optional" type="emptyContent" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="singleType" type="singleType"/&gt;


&lt;!-- Item type schema types and elements                                                --&gt;
  &lt;xsd:element name="itemType" abstract="true"/&gt;

  &lt;xsd:complexType name="contextItemType"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="itemType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="contextItemType" type="contextItemType" substitutionGroup="itemType"/&gt;


  &lt;xsd:complexType name="emptyItemTypeContent"/&gt;

  &lt;xsd:element name="anyItemType" type="emptyItemTypeContent"
               substitutionGroup="itemType"/&gt;


  &lt;xsd:simpleType name="occurrenceIndicator"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="?"/&gt;
      &lt;xsd:enumeration value="*"/&gt;
      &lt;xsd:enumeration value="+"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;


&lt;!-- Sequence type                                                                      --&gt;
  &lt;xsd:complexType name="sequenceType"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="voidSequenceType" type="emptyContent"/&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="itemType"/&gt;
        &lt;xsd:element name="occurrenceIndicator" type="occurrenceIndicator"
                     minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="sequenceType" type="sequenceType"/&gt;

  &lt;xsd:element name="typeDeclaration" type="sequenceType"/&gt;


&lt;!-- Union of sequence types                                                           --&gt;
  &lt;xsd:complexType name="sequenceTypeUnion"&gt;
    &lt;xsd:sequence minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xsd:element ref="sequenceType"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="sequenceTypeUnion" type="sequenceTypeUnion"/&gt;



&lt;!-- Represents a "typed" variable (for clause, let clause etc)                         --&gt;
  &lt;xsd:complexType name="typedVariableBinding"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="varName" type="EQName"/&gt;
      &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="typedVariableBinding" type="typedVariableBinding"/&gt;


&lt;!-- Represents an untyped variable for the "at" clause in a for clause                 --&gt;
  &lt;xsd:element name="positionalVariableBinding" type="EQName"/&gt;

  &lt;xsd:element name="variableBinding" type="EQName"/&gt;


&lt;!-- Represents all variable bindings in a for or let clause except typed and           --&gt;
&lt;!--   positional variable bindings                                                     --&gt;
  &lt;xsd:element name="forLetClauseItemExtensions" abstract="true"/&gt;


&lt;!-- Major syntax productions: FLWOR clause components                                  --&gt;
&lt;!-- for clause                                                                         --&gt;
  &lt;xsd:complexType name="forClauseItem"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="typedVariableBinding"/&gt;
      &lt;xsd:element name="allowingEmpty" type="emptyContent"
                   minOccurs="0"/&gt;
      &lt;xsd:element ref="positionalVariableBinding" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xsd:element ref="forLetClauseItemExtensions" minOccurs="0"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="forExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="forClauseItem" type="forClauseItem"/&gt;


  &lt;xsd:complexType name="forClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="forClauseItem" minOccurs="1" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="forClause" type="forClause"/&gt;


&lt;!-- let clause                                                                         --&gt;
  &lt;xsd:complexType name="letClauseItem"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="typedVariableBinding"/&gt;
          &lt;xsd:element ref="forLetClauseItemExtensions"
                       minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xsd:sequence&gt;
        &lt;xsd:element ref="forLetClauseItemExtensions"
                     minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:choice&gt;
      &lt;xsd:element name="letExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="letClauseItem" type="letClauseItem"/&gt;


  &lt;xsd:complexType name="letClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="letClauseItem" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="letClause" type="letClause"/&gt;


&lt;!-- This is the windowClause (part of FLWOR expression)                                --&gt;
&lt;!-- It corresponds to the following XQuery grammar                                     --&gt;
&lt;!--	WindowClause ::= "for" (TumblingWindowClause | SlidingWindowClause)               --&gt;
  &lt;xsd:complexType name="windowClause"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element ref="tumblingWindowClause"/&gt;
      &lt;xsd:element ref="slidingWindowClause"/&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="windowClause" type="windowClause"/&gt;


&lt;!-- This is the tumblingWindowClause                                                   --&gt;
&lt;!-- It corresponds to the following XQuery grammar                                     --&gt;
&lt;!-- TumblingWindowClause ::= "tumbling" "window" "$" VarName TypeDeclaration?          --&gt;
&lt;!--                           "in" ExprSingle WindowStartCondition WindowEndCondition? --&gt;
  &lt;xsd:complexType name="tumblingWindowClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="typedVariableBinding"/&gt;
      &lt;xsd:element name="bindingSequence" type="exprWrapper"/&gt;
      &lt;xsd:element ref="windowStartCondition"/&gt;
      &lt;xsd:element ref="windowEndCondition" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="tumblingWindowClause" type="tumblingWindowClause"/&gt;


&lt;!-- This is the slidingWindowClause                                                    --&gt;
&lt;!-- It corresponds to the following XQuery grammar                                     --&gt;
&lt;!-- SlidingWindowClause ::= "sliding" "window" "$" VarName TypeDeclaration?            --&gt;
&lt;!--                         "in" ExprSingle WindowStartCondition WindowEndCondition    --&gt;
  &lt;xsd:complexType name="slidingWindowClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="typedVariableBinding"/&gt;
      &lt;xsd:element name="bindingSequence" type="exprWrapper"/&gt;
      &lt;xsd:element ref="windowStartCondition"/&gt;
      &lt;xsd:element ref="windowEndCondition"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="slidingWindowClause" type="slidingWindowClause"/&gt;


&lt;!-- windowStartCondition                                                               --&gt;
&lt;!-- Corresponds to the following XQuery grammar                                        --&gt;
&lt;!-- WindowStartCondition ::= "start" WindowVars "when" ExprSingle                      --&gt;
  &lt;xsd:complexType name="windowStartCondition"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="windowVars" minOccurs="0"/&gt;
      &lt;xsd:element name="winStartExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="windowStartCondition" type="windowStartCondition"/&gt;


&lt;!-- windowEndCondition                                                                 --&gt;
&lt;!-- Corresponds to the following XQuery grammar                                        --&gt;
&lt;!-- WindowEndCondition 	   ::=    	"only"? "end" WindowVars "when" ExprSingle        --&gt;
  &lt;xsd:complexType name="windowEndCondition"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="windowVars" minOccurs="0"/&gt;
      &lt;xsd:element name="winEndExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="onlyEnd" type="xsd:boolean" default="false"/&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="windowEndCondition" type="windowEndCondition"/&gt;


&lt;!-- windowVars                                                                         --&gt;
&lt;!-- Corresponds to the following XQuery grammar                                        --&gt;
&lt;!-- WindowVars ::= ("$" \)? PositionalVar? ("previous" "$" PreviousItem)?    --&gt;
&lt;!--                ("next" "$" NextItem)?                                              --&gt;
  &lt;xsd:complexType name="windowVars"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="currentItem" type="EQName" minOccurs="0"/&gt;
      &lt;xsd:element ref="positionalVariableBinding" minOccurs="0"/&gt;
      &lt;xsd:element name="previousItem" type="EQName" minOccurs="0"/&gt;
      &lt;xsd:element name="nextItem" type="EQName" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="windowVars" type="windowVars"/&gt;


&lt;!-- countClause (part of FLWOR expression)                                             --&gt;
  &lt;xsd:complexType name="countClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="varRef"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="countClause" type="countClause"/&gt;


&lt;!-- whereClause (part of FLWOR expression)                                             --&gt;
  &lt;xsd:element name="whereClause" type="exprWrapper"/&gt;


&lt;!-- groupByClause (part of FLWOR expression)                                           --&gt;
&lt;!-- Corresponds to the following XQuery syntax                                         --&gt;
&lt;!-- GroupByClause ::= "group" "by" GroupingSpecList                                    --&gt;
&lt;!-- GroupingSpecList ::= GroupingSpec ("," GroupingSpec)*                              --&gt;
  &lt;xsd:complexType name="groupByClause"&gt;
    &lt;xsd:sequence maxOccurs="unbounded"&gt;
      &lt;xsd:element ref="groupingSpec"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="groupByClause" type="groupByClause"/&gt;


&lt;!-- Corresponds to the following XQuery syntax                                         --&gt;
&lt;!-- GroupingSpec ::=                                                                   --&gt;
&lt;!--     "$" VarName ( typeDeclaration? ":=" exprSingle )? ("collation" URILiteral)?    --&gt;
  &lt;xsd:complexType name="groupingSpec"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="varName" type="EQName"/&gt;
      &lt;xsd:element name="groupVarInitialize" minOccurs="0"&gt;
        &lt;xsd:complexType&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
            &lt;xsd:element name="varValue" type="exprWrapper"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;
      &lt;/xsd:element&gt;
      &lt;xsd:element name="collation" type="xsd:string" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="groupingSpec" type="groupingSpec"/&gt;


&lt;!-- order by clause                                                                    --&gt;
  &lt;xsd:simpleType name="emptyOrderingMode"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="empty greatest"/&gt;
      &lt;xsd:enumeration value="empty least"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:simpleType name="orderingKind"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="ascending"/&gt;
      &lt;xsd:enumeration value="descending"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;


  &lt;xsd:complexType name="orderModifier"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="orderingKind" type="orderingKind" minOccurs="0"/&gt;
      &lt;xsd:element name="emptyOrderingMode" type="emptyOrderingMode" minOccurs="0"/&gt;
      &lt;xsd:element name="collation" type="xsd:string" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="orderModifier" type="orderModifier"/&gt;


  &lt;xsd:complexType name="orderBySpec"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="orderByExpr" type="exprWrapper"/&gt;
      &lt;xsd:element ref="orderModifier" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="orderBySpec" type="orderBySpec"/&gt;


  &lt;xsd:complexType name="orderByClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="stable" type="emptyContent" minOccurs="0"/&gt;
      &lt;xsd:element ref="orderBySpec" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="orderByClause" type="orderByClause"/&gt;


&lt;!-- return clause                                                                      --&gt;
  &lt;xsd:element name="returnClause" type="exprWrapper"/&gt;


&lt;!-- This is the XQuery 1.1 flwor expression                                            --&gt;
&lt;!-- Corresponds to the following XQuery syntax:                                        --&gt;
&lt;!-- 1.1 FLWORExpr ::= (ForClause | LetClause | WindowClause)                           --&gt;
&lt;!--                   (ForClause | LetClause | WindowClause | CountClause |            --&gt;
&lt;!--                    WhereClause | GroupByClause | OrderByClause)*                   --&gt;
&lt;!--                   ReturnClause                                                     --&gt;
  &lt;xsd:complexType name="flworExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element ref="forClause"/&gt;
            &lt;xsd:element ref="letClause"/&gt;
            &lt;xsd:element ref="windowClause"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xsd:element ref="forClause"/&gt;
              &lt;xsd:element ref="letClause"/&gt;
              &lt;xsd:element ref="windowClause"/&gt;
              &lt;xsd:element ref="countClause"/&gt;
              &lt;xsd:element ref="whereClause"/&gt;
              &lt;xsd:element ref="groupByClause"/&gt;
              &lt;xsd:element ref="orderByClause"/&gt;
            &lt;/xsd:choice&gt;
          &lt;xsd:element ref="returnClause"/&gt;
        &lt;/xsd:sequence&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="flworExpr" type="flworExpr" substitutionGroup="expr"/&gt;


&lt;!-- conditional expressions                                                            --&gt;
  &lt;xsd:complexType name="ifThenElseExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ifClause" type="exprWrapper"/&gt;
          &lt;xsd:element name="thenClause" type="exprWrapper"/&gt;
          &lt;xsd:element name="elseClause" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ifThenElseExpr" type="ifThenElseExpr" 
               substitutionGroup="expr"/&gt;


&lt;!-- The following clauses describe quantified expressions                              --&gt;
  &lt;xsd:simpleType name="quantifier"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="some"/&gt;
      &lt;xsd:enumeration value="every"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;


  &lt;xsd:complexType name="quantifiedExprInClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="typedVariableBinding"/&gt;
      &lt;xsd:element name="sourceExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="quantifiedExprInClause" type="quantifiedExprInClause"/&gt;


  &lt;xsd:complexType name="quantifiedExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="quantifier" type="quantifier"/&gt;
          &lt;xsd:element ref="quantifiedExprInClause" maxOccurs="unbounded"/&gt;
          &lt;xsd:element name="predicateExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="quantifiedExpr" type="quantifiedExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- handle the switch expression                                                       --&gt;
&lt;!-- Note: no substitutionGroup as we cannot use this anywhere except within switch     --&gt;
  &lt;xsd:complexType name="switchExprCaseClause"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="switchCaseExpr" type="exprWrapper" maxOccurs="unbounded"/&gt;
          &lt;xsd:element name="resultExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="switchExprCaseClause"
               type="switchExprCaseClause"/&gt;


&lt;!-- Note: no substitutionGroup as we cannot use this anywhere except within switch     --&gt;
  &lt;xsd:complexType name="switchExprDefaultClause"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="resultExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="switchExprDefaultClause"
               type="switchExprDefaultClause"/&gt;


  &lt;xsd:complexType name="switchExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="switchExprCaseClause" maxOccurs="unbounded"/&gt;
          &lt;xsd:element ref="switchExprDefaultClause"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="switchExpr" type="switchExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- handle the typeswitch expression                                                   --&gt;
&lt;!-- Note: no substitutionGroup as we cannot use this anywhere except within typeswitch --&gt;
  &lt;xsd:complexType name="typeswitchExprCaseClause"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="variableBinding" minOccurs="0"/&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element ref="sequenceType"/&gt;
            &lt;xsd:element ref="sequenceTypeUnion"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="resultExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="typeswitchExprCaseClause"
               type="typeswitchExprCaseClause"/&gt;


&lt;!-- Note: no substitutionGroup as we cannot use this anywhere except within typeswitch --&gt;
  &lt;xsd:complexType name="typeswitchExprDefaultClause"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="variableBinding" minOccurs="0"/&gt;
          &lt;xsd:element name="resultExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="typeswitchExprDefaultClause"
               type="typeswitchExprDefaultClause"/&gt;


  &lt;xsd:complexType name="typeswitchExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="typeswitchExprCaseClause" maxOccurs="unbounded"/&gt;
          &lt;xsd:element ref="typeswitchExprDefaultClause"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="typeswitchExpr" type="typeswitchExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- TryCatchExpression                                                                 --&gt;
&lt;!-- Corresponds to the following XQuery syntax                                         --&gt;
&lt;!-- TryCatchExpression ::= TryClause CatchClause+                                      --&gt;
&lt;!-- TryClause ::= "{" TryTargetExpr "}"                                                --&gt;
&lt;!-- TryTargetExpr ::= Expr                                                             --&gt;
  &lt;xsd:complexType name="tryCatchExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="tryClause" type="exprWrapper"/&gt;
          &lt;xsd:element ref="catchClause" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="tryCatchExpr" type="tryCatchExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- CatchClause (part of the TryCatchExpression)                                       --&gt;
&lt;!-- Corresponds to the following XQuery syntax                                         --&gt;
&lt;!-- CatchClause ::= "catch" CatchErrorList "{" Expr "}"                                --&gt;
  &lt;xsd:complexType name="catchClause"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="catchErrorList"/&gt;
      &lt;xsd:element name="catchExpr" type="exprWrapper" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="catchClause" type="catchClause"/&gt;


&lt;!-- CatchErrorList (part of the TryCatchExpression)                                    --&gt;
&lt;!-- Corresponds to the following XQuery syntax                                         --&gt;
&lt;!-- CatchErrorList ::= NameTest ( "|" NameTest )*                                      --&gt;
&lt;!-- (remembering that NameTest is either QName or Wildcard)                            --&gt;
  &lt;xsd:complexType name="catchErrorList"&gt;
    &lt;xsd:sequence maxOccurs="unbounded"&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:element ref="nameTest"/&gt;
        &lt;xsd:element ref="Wildcard"/&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="catchErrorList" type="catchErrorList"/&gt;


&lt;!-- instance-of expressions                                                            --&gt;
  &lt;xsd:complexType name="instanceOfExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="sequenceType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="instanceOfExpr" type="instanceOfExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- treat-as expressions                                                               --&gt;
  &lt;xsd:complexType name="treatExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="sequenceType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="treatExpr" type="treatExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- castable and cast expressions                                                      --&gt;
  &lt;xsd:complexType name="castableExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="singleType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="castableExpr" type="castableExpr"
               substitutionGroup="expr"/&gt;


  &lt;xsd:complexType name="castExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="singleType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="castExpr" type="castExpr"
               substitutionGroup="expr"/&gt;


<phrase diff="add" at="2015-02-11">&lt;!-- 2015-02-11/JM Added arrowExpr (replacing arrowPostfix)                             --&gt;
&lt;!-- 2016-09-23/JS Bug 29823 - remove duplicate integerLiteral and variableRef          --&gt;
&lt;!-- Corresponds to XQuery syntax:                                                      --&gt;
&lt;!--   ArrowExpr   	          ::= UnaryExpr "=&gt;" ArrowFunctionSpecifier ArgumentList    --&gt;
&lt;!--   ArrowFunctionSpecifier ::= EQName | VarRef | ParenthesizedExpression             --&gt;
  &lt;xsd:complexType name="arrowExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:sequence minOccurs="1" maxOccurs="unbounded"&gt;
            &lt;xsd:choice&gt;
              &lt;xsd:element name="EQName" type="EQName"/&gt;
              &lt;xsd:element ref="expr"/&gt;
            &lt;/xsd:choice&gt;
            &lt;xsd:element name="arguments" type="exprOrPlaceholderList" minOccurs="0"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="arrowExpr" type="arrowExpr"
               substitutionGroup="expr"/&gt;


</phrase>&lt;!-- Validate expressions                                                               --&gt;
  &lt;xsd:simpleType name="validationMode"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="lax"/&gt;
      &lt;xsd:enumeration value="strict"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:complexType name="validateExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element name="validationMode" type="validationMode" minOccurs="0"/&gt;
            &lt;xsd:element name="typeName" type="EQName" minOccurs="0"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="validateExpr" type="validateExpr"
               substitutionGroup="expr"/&gt;


&lt;!-- Direct constructors. Only elementConstructor for now                               --&gt;
&lt;!-- Note the absence of constructors corresponding to                                  --&gt;
&lt;!-- the directCommentConstructor and the directPIConstructor                           --&gt;
&lt;!-- productions in the XQuery grammar. This is because they are                        --&gt;
&lt;!-- trivially identical to the computed variants                                       --&gt;

&lt;!-- attributeConstructor is no longer a subclass of expr                               --&gt;
  &lt;xsd:complexType name="attributeConstructor"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="attributeName" type="QName"/&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:element name="attributeValueExpr" type="exprList"/&gt;
        &lt;xsd:element name="attributeValue" type="xsd:string"/&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="namespaceDeclaration"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="prefix" type="xsd:NCName" minOccurs="0"/&gt;
      &lt;xsd:element name="uri" type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;


&lt;!-- element constructors                                                               --&gt;
  &lt;xsd:complexType name="attributeList"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:choice maxOccurs="unbounded"&gt;
        &lt;xsd:element name="attributeConstructor" type="attributeConstructor"/&gt;
        &lt;xsd:element name="namespaceDeclaration" type="namespaceDeclaration"/&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="attributeList" type="attributeList"/&gt;


  &lt;xsd:element name="elementContent" type="exprList"/&gt;


  &lt;xsd:complexType name="elementConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="tagName" type="QName"/&gt;
          &lt;xsd:element ref="attributeList" minOccurs="0"/&gt;
          &lt;xsd:element ref="elementContent" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="elementConstructor" type="elementConstructor"
               substitutionGroup="expr"/&gt;


&lt;!-- computed constructors                                                              --&gt;
&lt;!-- computed element constructor                                                       --&gt;
  &lt;xsd:complexType name="computedElementConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element name="tagName" type="EQName"/&gt;
            &lt;xsd:element name="tagNameExpr" type="exprWrapper"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="contentExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedElementConstructor" type="computedElementConstructor"
               substitutionGroup="expr"/&gt;


&lt;!-- computed attribute constructor                                                     --&gt;
  &lt;xsd:complexType name="computedAttributeConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element name="tagName" type="EQName"/&gt;
            &lt;xsd:element name="tagNameExpr" type="exprWrapper"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="valueExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedAttributeConstructor" type="computedAttributeConstructor"
               substitutionGroup="expr"/&gt;


&lt;!-- computed document constructor                                                      --&gt;
  &lt;xsd:complexType name="computedDocumentConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedDocumentConstructor" type="computedDocumentConstructor"
               substitutionGroup="expr"/&gt;


&lt;!-- computed text constructor                                                          --&gt;
  &lt;xsd:complexType name="computedTextConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedTextConstructor" type="computedTextConstructor"
               substitutionGroup="expr"/&gt;


&lt;!-- computed comment constructor                                                       --&gt;
  &lt;xsd:complexType name="computedCommentConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedCommentConstructor" type="computedCommentConstructor"
               substitutionGroup="expr"/&gt;


&lt;!-- computed namespace constructor                                                     --&gt;
  &lt;xsd:complexType name="computedNamespaceConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element name="prefix" type="xsd:NCName"/&gt;
            &lt;xsd:element name="prefixExpr" type="exprWrapper"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="URIExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedNamespaceConstructor" type="computedNamespaceConstructor"
               substitutionGroup="expr"/&gt;


&lt;!-- computed processing instruction constructor                                        --&gt;
  &lt;xsd:complexType name="computedPIConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element name="piTarget" type="xsd:NCName"/&gt;
            &lt;xsd:element name="piTargetExpr" type="exprWrapper"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="piValueExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedPIConstructor" type="computedPIConstructor"
               substitutionGroup="expr"/&gt;


&lt;!-- ordered and unordered expressions                                                  --&gt;
  &lt;xsd:complexType name="unorderedExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="unorderedExpr" type="unorderedExpr" substitutionGroup="expr"/&gt;


  &lt;xsd:complexType name="orderedExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="orderedExpr" type="orderedExpr" substitutionGroup="expr"/&gt;


&lt;!-- function item expressions                                                          --&gt;
&lt;!-- literal function item expression                                                   --&gt;
  &lt;xsd:complexType name="namedFunctionRef"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="functionName" type="EQName"/&gt;
          &lt;xsd:element name="integerConstantExpr" type="integerConstantExpr"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="namedFunctionRef" type="namedFunctionRef" substitutionGroup="expr"/&gt;


&lt;!-- inline function item expression                                                    --&gt;
  &lt;xsd:complexType name="inlineFunctionExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="annotation" type="annotation"
                       minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;xsd:element ref="paramList"/&gt;
          &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
          &lt;xsd:element name="functionBody" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="inlineFunctionExpr" type="inlineFunctionExpr" substitutionGroup="expr"/&gt;


&lt;!-- dynamic function invocations                                                       --&gt;
  &lt;xsd:complexType name="dynamicFunctionInvocationExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="functionItem"&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:group ref="filterExpr"/&gt;
              &lt;/xsd:sequence&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
          &lt;xsd:element name="predicates" type="exprList" minOccurs="0"/&gt;
          &lt;xsd:element name="arguments" type="exprOrPlaceholderList" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="dynamicFunctionInvocationExpr" type="dynamicFunctionInvocationExpr" substitutionGroup="expr"/&gt;


<phrase diff="add" at="2014-07-14">&lt;!-- 2014-07-13/JM Added mapConstructor                                                 --&gt;
&lt;!-- Corresponds to XQuery syntax:                                                      --&gt;
&lt;!-- MapConstructor ::= "map" "{" (MapConstructorEntry ("," MapConstructorEntry)*)? "}" --&gt;
&lt;!-- MapConstructorEntry ::= MapKeyExpr ":" MapValueExpr                                --&gt;
&lt;!-- MapKeyExpr ::= ExprSingle                                                          --&gt;
&lt;!-- MapValueExpr ::= ExprSingle                                                        --&gt;
  &lt;xsd:complexType name="mapConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="mapConstructorEntry" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="mapConstructor" type="mapConstructor" substitutionGroup="expr"/&gt;


  &lt;xsd:complexType name="mapConstructorEntry"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="mapKeyExpr" type="exprWrapper"/&gt;
      &lt;xsd:element name="mapValueExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="mapConstructorEntry" type="mapConstructorEntry"/&gt;


&lt;!-- 2014-07-13/JM Added arrayConstructor                                               --&gt;
&lt;!-- Corresponds to XQuery syntax:                                                      --&gt;
&lt;!-- ArrayConstructor ::= SquareArrayConstructor | CurlyArrayConstructor                --&gt;
&lt;!-- SquareArrayConstructor ::= "[" (ExprSingle ("," ExprSingle)*)? "]"                 --&gt;
&lt;!-- CurlyArrayConstructor ::= "array" "{" Expr? "}"                                    --&gt;
  &lt;xsd:complexType name="arrayConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:choice&gt;
          &lt;xsd:element ref="squareArray"/&gt;
          &lt;xsd:element ref="curlyArray"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="arrayConstructor" type="arrayConstructor" substitutionGroup="expr"/&gt;


  &lt;xsd:complexType name="squareArray"&gt;
    &lt;xsd:sequence minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xsd:element name="arrayElem" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="squareArray" type="squareArray"/&gt;


  &lt;xsd:complexType name="curlyArray"&gt;
    &lt;xsd:sequence minOccurs="0" maxOccurs="1"&gt;
      &lt;xsd:element name="arrayElem" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="curlyArray" type="curlyArray"/&gt;

<phrase diff="add" at="2015-11-05">&lt;!-- 2015-11-05/JS added stringConstructor                                              --&gt;
  &lt;xsd:complexType name="stringConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xsd:element name="stringConstructorChars" type="xsd:string"/&gt;
            &lt;xsd:element name="stringConstructorInterpolation" type="exprWrapperOptional"/&gt;
          &lt;/xsd:choice&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="stringConstructor" type="stringConstructor" substitutionGroup="expr"/&gt;


</phrase>&lt;!-- wildcards                                                                          --&gt;
  &lt;xsd:complexType name="simpleWildcard"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="QName" type="EQName"/&gt;
      &lt;xsd:element name="star" type="emptyContent"/&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

&lt;!-- Corresponds to the following XQuery syntax:                                                    --&gt;
&lt;!--   [44] Wildcard ::= "*"                                                                        --&gt;
&lt;!--                  | (NCName ":" "*")                                                            --&gt;
&lt;!--                  | ("*" ":" NCName)                                                            --&gt;
&lt;!--                  | (URILiteral ":" "*")                                                        --&gt;

  &lt;xsd:complexType name="Wildcard"&gt;
    &lt;xsd:choice minOccurs="0"&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="star" type="emptyContent"/&gt;
        &lt;xsd:element ref="NCName"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="NCName"/&gt;
        &lt;xsd:element name="star" type="emptyContent"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="uri" type="xsd:string"/&gt;
        &lt;xsd:element name="star" type="emptyContent"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="Wildcard" type="Wildcard"/&gt;


&lt;!-- tests (name and/or type)                                                           --&gt;
  &lt;xsd:element name="schemaAttributeTest" type="EQName"
               substitutionGroup="kindTest"/&gt;


  &lt;xsd:complexType name="attributeTest"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence minOccurs="0"&gt;
          &lt;xsd:element name="attributeName" type="simpleWildcard"/&gt;
          &lt;xsd:element name="typeName" type="EQName" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="attributeTest" type="attributeTest"
               substitutionGroup="kindTest"/&gt;


  &lt;xsd:element name="anyElementTest" abstract="true"
               substitutionGroup="kindTest"/&gt;


  &lt;xsd:element name="schemaElementTest" type="EQName"
               substitutionGroup="anyElementTest"/&gt;


  &lt;xsd:complexType name="elementTest"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence minOccurs="0"&gt;
          &lt;xsd:element name="elementName" type="simpleWildcard"/&gt;
          &lt;xsd:sequence minOccurs="0"&gt;
            &lt;xsd:element name="typeName" type="EQName"/&gt;
            &lt;xsd:element name="nillable" type="emptyContent" minOccurs="0"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="elementTest" type="elementTest"
               substitutionGroup="anyElementTest"/&gt;


  &lt;xsd:complexType name="documentTest"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence&gt;
           &lt;xsd:element ref="anyElementTest" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="documentTest" type="documentTest"
               substitutionGroup="kindTest"/&gt;


  &lt;xsd:complexType name="piTest"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="piTarget" type="xsd:NCName" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="piTest" type="piTest" substitutionGroup="kindTest"/&gt;


  &lt;xsd:element name="nameTest" type="EQName"/&gt;


&lt;!-- a kindTest is a kind of itemType --&gt;
  &lt;xsd:element name="kindTest" substitutionGroup="itemType"/&gt;

  &lt;xsd:element name="textTest" type="emptyItemTypeContent"
               substitutionGroup="kindTest"/&gt;

  &lt;xsd:element name="commentTest" type="emptyItemTypeContent"
               substitutionGroup="kindTest"/&gt;

  &lt;xsd:element name="namespaceTest" type="emptyItemTypeContent"
               substitutionGroup="kindTest"/&gt;

  &lt;xsd:element name="anyKindTest" type="emptyItemTypeContent"
               substitutionGroup="kindTest"/&gt;


&lt;!-- functionTest variations --&gt;
  &lt;xsd:complexType name="anyFunctionTest"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="annotation" type="annotation"
                       minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

&lt;!-- a functionTest is a kind of itemType --&gt;
  &lt;xsd:element name="anyFunctionTest" type="anyFunctionTest" substitutionGroup="itemType"/&gt;

  &lt;xsd:complexType name="typedFunctionTest"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="annotation" type="annotation"
                       minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;xsd:element ref="paramTypeList" minOccurs="0"/&gt;
          &lt;xsd:element ref="sequenceType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="typedFunctionTest" type="typedFunctionTest" substitutionGroup="itemType"/&gt;


  &lt;xsd:complexType name="paramTypeList"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="sequenceType" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="paramTypeList" type="paramTypeList"/&gt;


&lt;!-- a parenthesizedItemType is a kind of itemType --&gt;
  &lt;xsd:complexType name="parenthesizedItemType"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="itemType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="parenthesizedItemType" type="parenthesizedItemType" substitutionGroup="itemType"/&gt;


</phrase><phrase diff="add" at="2014-07-14">&lt;!-- 2014-07-13/JM Added anyMapTest and typedMapTest                                    --&gt;
&lt;!-- mapTest variations --&gt;
&lt;!-- a mapTest is a kind of itemType --&gt;
  &lt;xsd:element name="anyMapTest" type="emptyItemTypeContent" substitutionGroup="itemType"/&gt;

  &lt;xsd:complexType name="typedMapTest"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="atomicType"/&gt;
          &lt;xsd:element ref="sequenceType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="typedMapTest" type="typedMapTest" substitutionGroup="itemType"/&gt;


&lt;!-- 2014-07-13/JM Added anyArrayTest and typedArrayTest                                --&gt;
&lt;!-- arrayTest variations --&gt;
&lt;!-- an arrayTest is a kind of itemType --&gt;
  &lt;xsd:element name="anyArrayTest" type="emptyItemTypeContent" substitutionGroup="itemType"/&gt;

  &lt;xsd:complexType name="typedArrayTest"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="emptyItemTypeContent"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="sequenceType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="typedArrayTest" type="typedArrayTest" substitutionGroup="itemType"/&gt;


&lt;!-- 2016-09-23/JS : Bug 29823 - remove duplicate integerLiteral and variableRef          --&gt;
&lt;!-- 2014-07-13/JM Added lookup (formerly mapLookup)                                      --&gt;
&lt;!-- Corresponds to XQuery syntax:                                                        --&gt;
&lt;!--   Lookup          ::=   	"?" KeySpecifier                                          --&gt;
&lt;!--   UnaryLookup     ::=   	"?" KeySpecifier                                          --&gt;
&lt;!--   KeySpecifier    ::=   	NCName | IntegerLiteral | ParenthesizedExpr | "*"         --&gt;
  &lt;xsd:complexType name="lookup"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element ref="NCName"/&gt;
            &lt;xsd:element ref="expr"/&gt;
            &lt;xsd:element name="star" type="emptyContent"/&gt;
          &lt;/xsd:choice&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="lookup" type="lookup"/&gt;

  &lt;xsd:element name="unaryLookup" type="lookup"
               substitutionGroup="expr"/&gt;


</phrase>&lt;!-- XPath axes                                                                         --&gt;
  &lt;xsd:simpleType name="xpathAxis"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="child"/&gt;
      &lt;xsd:enumeration value="attribute"/&gt;
      &lt;xsd:enumeration value="self"/&gt;
      &lt;xsd:enumeration value="parent"/&gt;
      &lt;xsd:enumeration value="descendant-or-self"/&gt;
      &lt;xsd:enumeration value="descendant"/&gt;
      &lt;xsd:enumeration value="following"/&gt;
      &lt;xsd:enumeration value="following-sibling"/&gt;
      &lt;xsd:enumeration value="ancestor"/&gt;
      &lt;xsd:enumeration value="ancestor-or-self"/&gt;
      &lt;xsd:enumeration value="preceding"/&gt;
      &lt;xsd:enumeration value="preceding-sibling"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:element name="xpathAxis" type="xpathAxis"/&gt;


&lt;!-- filter expressions                                                                 --&gt;
&lt;!-- 2014-07-13/JM added mapConstructor, arrayConstructor, and unaryLookup              --&gt;
  &lt;xsd:group name="filterExpr"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element ref="constantExpr"/&gt;
      &lt;xsd:element ref="varRef"/&gt;
      &lt;xsd:element ref="contextItemExpr"/&gt;
      &lt;xsd:element ref="functionCallExpr"/&gt;
      &lt;xsd:element ref="sequenceExpr"/&gt;
      &lt;xsd:element ref="elementConstructor"/&gt;
      &lt;xsd:element ref="computedElementConstructor"/&gt;
      &lt;xsd:element ref="computedAttributeConstructor"/&gt;
      &lt;xsd:element ref="computedDocumentConstructor"/&gt;
      &lt;xsd:element ref="computedTextConstructor"/&gt;
      &lt;xsd:element ref="computedCommentConstructor"/&gt;
      &lt;xsd:element ref="computedNamespaceConstructor"/&gt;
      &lt;xsd:element ref="computedPIConstructor"/&gt;
      &lt;xsd:element ref="orderedExpr"/&gt;
      &lt;xsd:element ref="unorderedExpr"/&gt;
      &lt;xsd:element ref="namedFunctionRef"/&gt;
      &lt;xsd:element ref="inlineFunctionExpr"/&gt;
      &lt;xsd:element ref="dynamicFunctionInvocationExpr"/&gt;
<phrase diff="add" at="2014-07-14">      &lt;xsd:element ref="mapConstructor"/&gt;
      &lt;xsd:element ref="arrayConstructor"/&gt;
      &lt;xsd:element ref="stringConstructor"/&gt;
      &lt;xsd:element ref="unaryLookup"/&gt;
</phrase>    &lt;/xsd:choice&gt;
  &lt;/xsd:group&gt;


&lt;!-- step expression                                                                    --&gt;
&lt;!-- 2014-07-13/JM Added alts to predicates to support lookup (formerly mapLookup)      --&gt;
  &lt;xsd:complexType name="stepExpr"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="xpathAxis"/&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element ref="kindTest"/&gt;
            &lt;xsd:element ref="nameTest"/&gt;
            &lt;xsd:element ref="Wildcard"/&gt;
          &lt;/xsd:choice&gt;
<phrase diff="add" at="2014-07-14">          &lt;xsd:element name="predicates" type="exprList" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="filterExpr"&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:group ref="filterExpr"/&gt;
              &lt;/xsd:sequence&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element name="predicates" type="exprList" minOccurs="0"/&gt;
            &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xsd:element name="predicate"&gt;
                &lt;xsd:complexType&gt;
                  &lt;xsd:sequence&gt;
                    &lt;xsd:element ref="expr"/&gt;
                  &lt;/xsd:sequence&gt;
                &lt;/xsd:complexType&gt;
              &lt;/xsd:element&gt;
              &lt;xsd:element ref="lookup"/&gt;
            &lt;/xsd:choice&gt;
          &lt;/xsd:choice&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:choice&gt;
</phrase>    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="stepExpr" type="stepExpr"/&gt;


&lt;!-- path expression                                                                    --&gt;
  &lt;xsd:complexType name="pathExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:choice&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element name="rootExpr" type="emptyContent"/&gt;
            &lt;xsd:element ref="stepExpr" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xsd:sequence&gt;
          &lt;xsd:element ref="stepExpr" maxOccurs="unbounded"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="pathExpr" type="pathExpr" substitutionGroup="expr"/&gt;


&lt;!-- The following constructs deal with the query prolog                                --&gt;
  &lt;xsd:complexType name="module"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="versionDecl" minOccurs="0"/&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:element ref="mainModule"/&gt;
        &lt;xsd:element ref="libraryModule"/&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="module" type="module"/&gt;


  &lt;xsd:complexType name="mainModule"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="prolog" minOccurs="0"/&gt;
      &lt;xsd:element name="queryBody" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="mainModule" type="mainModule"/&gt;


  &lt;xsd:complexType name="libraryModule"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="moduleDecl"/&gt;
      &lt;xsd:element ref="prolog" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="libraryModule" type="libraryModule"/&gt;


&lt;!-- Corrected versionDecl element to require at least one of version or encoding --&gt;
  &lt;xsd:complexType name="versionDecl"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="version" type="xsd:string"/&gt;
        &lt;xsd:element name="encoding" type="xsd:string" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:element name="encoding" type="xsd:string"/&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="versionDecl" type="versionDecl"/&gt;


  &lt;xsd:complexType name="prolog"&gt;
    &lt;xsd:sequence&gt;
	    &lt;xsd:element ref="prologPartOneItem" minOccurs="0" maxOccurs="unbounded"/&gt;
	    &lt;xsd:element ref="prologPartTwoItem" minOccurs="0" maxOccurs="unbounded"/&gt;
	  &lt;/xsd:sequence&gt;
	&lt;/xsd:complexType&gt;

  &lt;xsd:element name="prolog" type="prolog"/&gt;


  &lt;xsd:element name="prologPartOneItem" abstract="true"/&gt;


  &lt;xsd:element name="prologPartTwoItem" abstract="true"/&gt;


  &lt;xsd:simpleType name="boundarySpaceDecl"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="strip"/&gt;
      &lt;xsd:enumeration value="preserve"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:element name="boundarySpaceDecl" type="boundarySpaceDecl"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:element name="defaultCollationDecl" type="xsd:string"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:element name="baseUriDecl" type="xsd:string"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:simpleType name="constructionDecl"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="strip"/&gt;
      &lt;xsd:enumeration value="preserve"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:element name="constructionDecl" type="constructionDecl"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:simpleType name="orderingModeDecl"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="ordered"/&gt;
      &lt;xsd:enumeration value="unordered"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:element name="orderingModeDecl" type="orderingModeDecl"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:element name="emptyOrderingDecl" type="emptyOrderingMode"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:complexType name="copyNamespacesDecl"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="preserveMode"&gt;
        &lt;xsd:simpleType&gt;
          &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
            &lt;xsd:enumeration value="preserve"/&gt;
            &lt;xsd:enumeration value="no-preserve"/&gt;
          &lt;/xsd:restriction&gt;
        &lt;/xsd:simpleType&gt;
      &lt;/xsd:element&gt;
      &lt;xsd:element name="inheritMode"&gt;
        &lt;xsd:simpleType&gt;
          &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
            &lt;xsd:enumeration value="inherit"/&gt;
            &lt;xsd:enumeration value="no-inherit"/&gt;
          &lt;/xsd:restriction&gt;
        &lt;/xsd:simpleType&gt;
      &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="copyNamespacesDecl" type="copyNamespacesDecl"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:simpleType name="defaultNamespaceCategory"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="function"/&gt;
      &lt;xsd:enumeration value="element"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:complexType name="defaultNamespaceDecl"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="defaultNamespaceCategory" type="defaultNamespaceCategory"/&gt;
      &lt;xsd:element name="uri" type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="defaultNamespaceDecl" type="defaultNamespaceDecl"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:complexType name="namespaceDeclType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="prefix" type="xsd:NCName"/&gt;
      &lt;xsd:element name="uri" type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="namespaceDecl" type="namespaceDeclType"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:element name="moduleDecl" type="namespaceDeclType"/&gt;


  &lt;xsd:complexType name="decimalFormatDeclType"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="decimalFormatName" type="EQName" minOccurs="0"/&gt;
          &lt;xsd:element name="decimalFormatParam" minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:element name="decimalFormatParamName"&gt;
                  &lt;xsd:simpleType&gt;
                    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
                      &lt;xsd:enumeration value="decimal-separator"/&gt;
                      &lt;xsd:enumeration value="grouping-separator"/&gt;
                      &lt;xsd:enumeration value="infinity"/&gt;
                      &lt;xsd:enumeration value="minus-sign"/&gt;
                      &lt;xsd:enumeration value="NaN"/&gt;
                      &lt;xsd:enumeration value="percent"/&gt;
                      &lt;xsd:enumeration value="per-mille"/&gt;
                      &lt;xsd:enumeration value="zero-digit"/&gt;
                      &lt;xsd:enumeration value="digit"/&gt;
                      &lt;xsd:enumeration value="pattern-separator"/&gt;
<phrase diff="add" at="2014-12-31">                      &lt;xsd:enumeration value="exponent-separator"/&gt;
</phrase>                    &lt;/xsd:restriction&gt;
                  &lt;/xsd:simpleType&gt;
                &lt;/xsd:element&gt;
                &lt;xsd:element name="decimalFormatParamValue" type="xsd:string"/&gt;
              &lt;/xsd:sequence&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="decimalFormatDecl" type="decimalFormatDeclType"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:complexType name="schemaImport"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:choice minOccurs="0"&gt;
        &lt;xsd:element name="namespacePrefix" type="xsd:NCName"/&gt;
        &lt;xsd:element name="defaultElementNamespace" type="emptyContent"/&gt;
      &lt;/xsd:choice&gt;
      &lt;xsd:element name="targetNamespace" type="xsd:string"/&gt;
      &lt;xsd:element name="targetLocation" type="xsd:string"
                   minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="schemaImport" type="schemaImport"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:complexType name="moduleImport"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="namespacePrefix" type="xsd:NCName" minOccurs="0"/&gt;
      &lt;xsd:element name="targetNamespace" type="xsd:string"/&gt;
      &lt;xsd:element name="targetLocation" type="xsd:string"
                   minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="moduleImport" type="moduleImport"
               substitutionGroup="prologPartOneItem"/&gt;


  &lt;xsd:complexType name="contextItemDecl"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="contextItemType" minOccurs="0"/&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:element name="varValue" type="exprWrapper"/&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="external"&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:element name="varValue" type="exprWrapper" minOccurs="0"/&gt;
              &lt;/xsd:sequence&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="contextItemDecl" type="contextItemDecl"
               substitutionGroup="prologPartTwoItem"/&gt;


&lt;!-- For %-annotations                                                                  --&gt;
  &lt;xsd:complexType name="annotation"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="annotationName" type="EQName"/&gt;
      &lt;xsd:element name="arguments" type="literalList" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;


  &lt;xsd:complexType name="varDecl"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="annotation" type="annotation"
                   minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="varName" type="EQName"/&gt;
      &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:element name="varValue" type="exprWrapper"/&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="external"&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:element name="varValue" type="exprWrapper" minOccurs="0"/&gt;
              &lt;/xsd:sequence&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="varDecl" type="varDecl"
               substitutionGroup="prologPartTwoItem"/&gt;


  &lt;xsd:complexType name="optionDecl"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="optionName" type="EQName"/&gt;
      &lt;xsd:element name="optionContents" type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="optionDecl" type="optionDecl"
               substitutionGroup="prologPartTwoItem"/&gt;


&lt;!-- function declarations can no longer specify "nondeterministic" or "private"              --&gt;
  &lt;xsd:complexType name="functionDecl"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="annotation" type="annotation"
                   minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="functionName" type="EQName"/&gt;
      &lt;xsd:element ref="paramList"/&gt;
      &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:element name="functionBody" type="exprWrapper"/&gt;
        &lt;xsd:element name="externalDefinition" type="emptyContent"/&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="functionDecl" type="functionDecl"
               substitutionGroup="prologPartTwoItem"/&gt;


  &lt;xsd:complexType name="param"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="varName" type="EQName"/&gt;
      &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="param" type="param"/&gt;


  &lt;xsd:complexType name="paramList"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="param" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="paramList" type="paramList"/&gt;


&lt;/xsd:schema&gt;

</eg></div1><!-- Trivial Embedding, an At Risk feature, was dropped by the Joint XML Query and XSL WG meeting
     on 2006-11-02

    <div1 id="TrivialEmbedding">
      <head>A Trivial Embedding of XQuery</head>
      <p>
        <specref ref="Introduction"/> observed that the
<bibref ref="xquery-requirements"/> says <quote>The XML Query Language MAY have
more than one syntax binding. One query language syntax MUST be convenient for
humans to read and write. One query language syntax MUST be expressed in XML in
a way that reflects the underlying structure of the query.</quote>
There are many possible ways to define an XML syntax for XQuery. 
This document specifies two XML Syntaxes for XQuery: 
the one in <specref ref="Schema"/> and the <quote>trivial embedding</quote>
defined in this section. 
Of course, XQueries could be expressed in XML Syntax in other ways.</p>

      <p>The trivial embedding specified here can be used when an
      XQuery is exchanged with other entities as XML or embedded
      in an XML document, and when it is not necessary to communicate
      the underlying structure of the query. 
      When this alternative is chosen, the XQuery expression is treated
      as though it were ordinary text. </p>

      <p>The trivial embedding defined in this specification requires that the
entire query be enclosed within an element named "xquery" in the XQueryX namespace
(the "xqx:" namespace prefix is used here only for the purposes of this example),
as illustrated here:</p>

      <eg>&lt;xqx:xquery&gt;for $i... let $j...where $x = $y...return...&lt;/xqx:xquery&gt;</eg>

< ! - -  Response to Bugzilla bug #2611 - - >
<p>
XQuery expressions are, for the purposes of this trivial embedding, treated 
as literal text. Therefore, if the XQuery contains characters that are 
prohibited in XML text (specifically &lt; and &amp;), they must be "escaped" as 
character entity references (&amp;lt; and &amp;amp;, respectively) or as numeric 
character references (for example, &amp;#x3C; and &amp;#x26;, respectively), or 
they must be enclosed in a CDATA section (for example, &lt;![CDATA[&lt;]] or 
&lt;![CDATA[&amp;]]).  Note that this includes the leading "&lt;" of a CDATA section 
that appears in the original XQuery expression.  In addition, because the 
sequence of characters "]]&gt;" is always prohibited within element content,
it is recommended that instances of &gt; in the original XQuery always be 
"escaped" (for example, as &amp;gt;, &amp;#x3E;, or &lt;![CDATA[&gt;]]).
</p>

      <eg>&lt;xqx:xquery&gt;for $i... let $j...where $x &amp;lt; $y...return...&lt;/xqx:xquery&gt;</eg>

      <p>or</p>

      <eg>&lt;xqx:xquery&gt;for $i... let $j...where $x &amp;x003C; $y...return...&lt;/xqx:xquery&gt;</eg>

      <p>This limitation may require that user agents scan the XQuery text, escaping such
prohibited characters, before transmitting or embedding the XQuery as XML. </p>

< ! - - Response to Bugzilla bug #2611 - - >
< ! - - Response to Bugzilla bug #3056 - - >
      <p>The following two more complete examples (which are equivalent to one another
      and to "<code>for $i in (1 to 5) let $j := 4 where $i &lt; $j return
  &lt;x&gt;&lt;i&gt;{$i}&lt;/i&gt;&lt;/x&gt;</code>") further illustrate the use of the
         XQueryX trivial embedding. </p>

      <eg>&lt;xqx:xquery&gt;for $i in (1 to 5) let $j := 4 where $i &amp;lt; $j return
  &lt;x&gt;&lt;i&gt;{$i}&lt;/i&gt;&lt;/x&gt;&lt;/xqx:xquery&gt;

&lt;xqx:xquery&gt;&lt;![CDATA[for $i in (1 to 5) let $j := 4 where $i &lt; $j
  return &lt;x&gt;&lt;i&gt;{$i}&lt;/i&gt;&lt;/x&gt;]]&gt;&lt;/xqx:xquery&gt;</eg>

    </div1>
--><div1 id="xqx_conformance"><head>Conformance</head><p>This section defines the conformance criteria for an XQueryX processor
         (see Figure 1, "Processing Model Overview", in <phrase diff="chg">
               <bibref ref="xquery-31"/>
            </phrase>,
         <xspecref diff="chg" spec="XQ31" ref="id-processing-model"/>. 
      </p><p>In this section, the following terms are used to indicate the
         requirement levels defined in <bibref ref="RFC2119"/>. 
         [Definition: MUST means that the item is an absolute requirement of the specification.]
         [Definition: SHOULD means that there may exist valid reasons in particular
         circumstances to ignore a particular item, but the full implications
         must be understood and carefully weighed before choosing a different course.]
         [Definition: MAY means that an item is truly optional.] </p><p>An XQueryX processor that claims to conform to this specification MUST
         implement the XQueryX syntax as defined in <specref ref="Schema"/> of this
         specification and include a claim of Minimal Conformance as defined in
         <phrase diff="chg">
               <bibref ref="xquery-31"/>
            </phrase>,
         <xspecref diff="chg" spec="XQ31" ref="id-minimal-conformance"/>. 
         In addition to a claim of Minimal Conformance, it MAY claim conformance to
         one or more optional features defined in
         <phrase diff="chg">
               <bibref ref="xquery-31"/>
            </phrase>,
         <xspecref diff="chg" spec="XQ31" ref="id-conform-optional-features"/>. </p></div1></body><back><div1 id="biblio"><head>References</head><!-- RFC refs changed per re-opened Bugzilla bug #1345 --><blist><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xqueryx-30" key="XQueryX 3.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-use-cases" key="XML Query Use Cases" diff="chg" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-31" key="XQuery 3.1: An XML Query Language" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-functions-31" key="XQuery and XPath Functions and Operators 3.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-semantics" key="XQuery 1.0 and XPath 2.0 Formal Semantics" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2119" key="RFC 2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">S. Bradner. 
          <emph>Key Words for use in RFCs to Indicate Requirement Levels.</emph> IETF RFC 2119. 
          See <loc href="http://www.ietf.org/rfc/rfc2119.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc2119.txt</loc>.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3023" key="RFC 3023" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">M. Murata, S. St. Laurent, and D. Kohn. 
          <emph>XML Media Types</emph> IETF RFC 3023 or its successors. 
          See <loc href="http://www.ietf.org/rfc/rfc3023.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3023.txt</loc>.</bibl><!--        <bibl id="RFC3986" key="RFC 3986">T. Berners-Lee, R. Fielding, and L. Masinter. 
		  <emph>Uniform Resource Identifiers (URI): Generic Syntax</emph>. IETF RFC 3986. 
		  See <loc href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</loc>.</bibl> --></blist></div1><div1 id="Stylesheet"><head>Transforming XQueryX to XQuery</head><p>The following stylesheet converts from XQueryX syntax to XQuery syntax. 
         Note the intent of the stylesheet is to produce <emph>a</emph> valid XQuery with the
         same semantics (see <bibref ref="xquery-semantics"/>) as the input XQueryX.</p><eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;!--  ================================================================================  --&gt;
&lt;!--  Changes from Recommendation (XQueryX 3.0):                                        --&gt;
&lt;!--  ================================================================================  --&gt;
&lt;!--  Errata applied:                                                                   --&gt;
&lt;!--  ================================================================================  --&gt;
&lt;!--  Modifications:                                                                    --&gt;
&lt;!--    JM/2014-07-11 : Added support for anyMapText and typedMapTest                   --&gt;
&lt;!--    JM/2014-07-11 : Added support for anyArrayText and typedArrayTest               --&gt;
&lt;!--    JM/2014-07-13 : Added support for new alternatives in stepExpr                  --&gt;
&lt;!--    JM/2014-07-13 : Added support for lookup (formerly mapLookup)                   --&gt;
&lt;!--    JM/2014-07-13 : Added support for unaryLookup (formerly unaryMapLookup)         --&gt;
&lt;!--    JM/2014-07-13 : Added support for new alternatives in filterExpr                --&gt;
&lt;!--    JM/2014-07-13 : Added support for mapConstructor and arrayConstructor           --&gt;
&lt;!--    JM/2014-08-28 : Fixed [unary]Lookup replacing stringLiteral w/integerLiteral    --&gt;
&lt;!--    JM/2015-02-11 : Replaced arrowPostfix with arrowExpr per bug 27537              --&gt;
&lt;!--    JS/2015-11-05 : Added support for stringConstructor                             --&gt;
&lt;!--    JS/2016-01-20 : Added support for unaryLookup per bug 29364                     --&gt;
&lt;!--    JS/2016-01-20 : Added xqx:EQName to renderEQName per bug 29365                  --&gt;
&lt;!--    JS/2016-09-23 : Bug 29823 - remove duplicate integerLiteral and variableRef     --&gt;
&lt;!--    JS/2016-11-01 : Bug 29868 - does not always convert arrowExpr to XQuery         --&gt;
&lt;!--  ================================================================================  --&gt;
&lt;xsl:stylesheet version="2.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:xqx="http://www.w3.org/2005/XQueryX"&gt;

&lt;!-- Note that this stylesheet frequently invokes templates for
     specified elements, even when there are no templates in the
     stylesheet whose match="" attribute identifies those elements.
     In such case, the default template's element matching template
     is invoked, which merely invokes xsl:apply-templates --&gt;

  &lt;xsl:output method="text"/&gt;
  &lt;xsl:strip-space elements="*"/&gt;
  &lt;xsl:preserve-space elements="xqx:value xqx:attributeValue xqx:pragmaContents
                                xqx:optionContents xqx:xquery xqx:stringConstructorChars"/&gt;

  &lt;xsl:variable name="DOT" select="'.'"/&gt;
  &lt;xsl:variable name="SPACE" select="' '"/&gt;
  &lt;xsl:variable name="SLASH" select="'/'"/&gt;
  &lt;xsl:variable name="SLASH_SLASH" select="'//'"/&gt;
  &lt;xsl:variable name="LESSTHAN" select="'&amp;lt;'"/&gt;
  &lt;xsl:variable name="GREATERTHAN" select="'&amp;gt;'"/&gt;
  &lt;xsl:variable name="LPAREN" select="'('"/&gt;
  &lt;xsl:variable name="RPAREN" select="')'"/&gt;
  &lt;xsl:variable name="NEWLINE"&gt;&lt;xsl:text&gt;
&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
  &lt;xsl:variable name="COMMA" select="','"/&gt;
  &lt;xsl:variable name="COMMA_SPACE" select="', '"/&gt;
  &lt;xsl:variable name="COMMA_NEWLINE"&gt;&lt;xsl:text&gt;,
&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
  &lt;xsl:variable name="QUOTE"&gt;&lt;xsl:text&gt;'&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
  &lt;xsl:variable name="DOUBLEQUOTE"&gt;&lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
  &lt;xsl:variable name="TO" select="' to '"/&gt;
  &lt;xsl:variable name="LBRACE" select="'{'"/&gt;
  &lt;xsl:variable name="RBRACE" select="'}'"/&gt;
  &lt;xsl:variable name="LBRACKET" select="'['"/&gt;
  &lt;xsl:variable name="RBRACKET" select="']'"/&gt;
  &lt;xsl:variable name="DOLLAR" select="'$'"/&gt;
  &lt;xsl:variable name="MINUS" select="'-'"/&gt;
  &lt;xsl:variable name="PLUS" select="'+'"/&gt;
  &lt;xsl:variable name="EQUAL" select="'='"/&gt;
  &lt;xsl:variable name="COLON" select="':'"/&gt;
  &lt;xsl:variable name="DOUBLE_COLON" select="'::'"/&gt;
  &lt;xsl:variable name="SEMICOLON" select="';'"/&gt;
  &lt;xsl:variable name="AT" select="'@'"/&gt;
  &lt;xsl:variable name="STAR" select="'*'"/&gt;
  &lt;xsl:variable name="QUESTIONMARK" select="'?'"/&gt;
  &lt;xsl:variable name="EXCLAMATIONMARK" select="'!'"/&gt;
  &lt;xsl:variable name="PERCENT" select="'%'"/&gt;
  &lt;xsl:variable name="ASSIGN" select="':='"/&gt;
  &lt;xsl:variable name="SEPARATOR" select="';'"/&gt;
  &lt;xsl:variable name="PRAGMA_BEGIN" select="'(# '"/&gt;
  &lt;xsl:variable name="PRAGMA_END" select="' #)'"/&gt;
  &lt;xsl:variable name="CONCATENATE" select="'||'"/&gt;


  &lt;xsl:template name="delimitedList"&gt;
    &lt;xsl:param name="delimiter" /&gt;
    &lt;xsl:param name="leftEncloser"/&gt;
    &lt;xsl:param name="rightEncloser" /&gt;
    &lt;xsl:param name="selector"/&gt;

    &lt;xsl:value-of select="$leftEncloser"/&gt;
    &lt;xsl:for-each select="*"&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:if test="not (position()=last())"&gt;        
        &lt;xsl:value-of select="$delimiter"/&gt;
      &lt;/xsl:if&gt;       
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$rightEncloser"/&gt;
  &lt;/xsl:template&gt;   


  &lt;xsl:template name="parenthesizedList"&gt;
    &lt;xsl:param name="delimiter" select="$COMMA_SPACE"/&gt;
    &lt;xsl:call-template name="delimitedList"&gt;
      &lt;xsl:with-param name="delimiter" select="$delimiter" /&gt;
      &lt;xsl:with-param name="leftEncloser" select="$LPAREN"/&gt;
      &lt;xsl:with-param name="rightEncloser" select="$RPAREN"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template name="commaSeparatedList"&gt;
    &lt;xsl:call-template name="delimitedList"&gt;
      &lt;xsl:with-param name="delimiter"&gt;
        &lt;xsl:value-of select="$COMMA_SPACE"/&gt;
      &lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template name="quote"&gt;
    &lt;xsl:param name="item"/&gt;
    &lt;xsl:value-of select="$DOUBLEQUOTE"/&gt;
    &lt;xsl:call-template name="globalReplace"&gt;
      &lt;xsl:with-param name="stringToBeFixed"&gt;
        &lt;xsl:call-template name="globalReplace"&gt;
          &lt;xsl:with-param name="stringToBeFixed"&gt;
            &lt;xsl:call-template name="globalReplace"&gt;
              &lt;xsl:with-param name="stringToBeFixed"&gt;
                &lt;xsl:call-template name="globalReplace"&gt;
                  &lt;xsl:with-param name="stringToBeFixed"&gt;
                    &lt;xsl:call-template name="globalReplace"&gt;
                      &lt;xsl:with-param name="stringToBeFixed"&gt;
                        &lt;xsl:call-template name="globalReplace"&gt;
                          &lt;xsl:with-param name="stringToBeFixed"&gt;
                            &lt;xsl:value-of select="$item"/&gt;
                          &lt;/xsl:with-param&gt;
                          &lt;xsl:with-param name="toBeReplaced"&gt;&amp;amp;&lt;/xsl:with-param&gt;
                          &lt;xsl:with-param name="replacement"&gt;&amp;amp;amp;&lt;/xsl:with-param&gt;
                        &lt;/xsl:call-template&gt;
                                      &lt;/xsl:with-param&gt;
                      &lt;xsl:with-param name="toBeReplaced"&gt;&amp;lt;&lt;/xsl:with-param&gt;
                      &lt;xsl:with-param name="replacement"&gt;&amp;amp;lt;&lt;/xsl:with-param&gt;
                    &lt;/xsl:call-template&gt;
                  &lt;/xsl:with-param&gt;
                  &lt;xsl:with-param name="toBeReplaced" select="'&amp;#x85;'"/&gt;
                  &lt;xsl:with-param name="replacement"&gt;&amp;amp;#x85;&lt;/xsl:with-param&gt;
                &lt;/xsl:call-template&gt;
              &lt;/xsl:with-param&gt;
              &lt;xsl:with-param name="toBeReplaced" select="'&amp;#xD;'"/&gt;
              &lt;xsl:with-param name="replacement"&gt;&amp;amp;#xD;&lt;/xsl:with-param&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="toBeReplaced" select="'&amp;#x2028;'"/&gt;
          &lt;xsl:with-param name="replacement"&gt;&amp;amp;#x2028;&lt;/xsl:with-param&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:with-param&gt;
      &lt;xsl:with-param name="toBeReplaced"&gt;&lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
      &lt;xsl:with-param name="replacement"&gt;&lt;xsl:text&gt;""&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:value-of select="$DOUBLEQUOTE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template name="globalReplace"&gt;
    &lt;xsl:param name="stringToBeFixed"/&gt;
    &lt;xsl:param name="toBeReplaced"/&gt;
    &lt;xsl:param name="replacement"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="contains($stringToBeFixed, $toBeReplaced)"&gt;
        &lt;xsl:value-of select="concat(substring-before($stringToBeFixed, $toBeReplaced), $replacement)"/&gt;
        &lt;xsl:call-template name="globalReplace"&gt;
          &lt;xsl:with-param name="stringToBeFixed" select="substring-after($stringToBeFixed, $toBeReplaced)"/&gt;
          &lt;xsl:with-param name="toBeReplaced" select="$toBeReplaced"/&gt;
          &lt;xsl:with-param name="replacement" select="$replacement"/&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$stringToBeFixed"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template name="renderQName"&gt;
    &lt;xsl:if test="@xqx:prefix"&gt;
      &lt;xsl:value-of select="@xqx:prefix"/&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template name="renderEQName"
                match="xqx:QName | xqx:EQName | xqx:pragmaName | xqx:typeName | xqx:varName |
                       xqx:functionName | xqx:optionName | xqx:annotationName |
                       xqx:atomicType | xqx:tagName | xqx:name | xqx:decimalFormatName"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:tagName/parent::xqx:elementConstructor"&gt;
        &lt;xsl:call-template name="renderQName"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:choose&gt;
          &lt;xsl:when test="@xqx:prefix and @xqx:URI"&gt;
            &lt;xsl:message terminate="yes"&gt;Incorrect XQueryX: Elements of type xqx:EQName must not have both 'prefix' and 'URI' attributes&lt;/xsl:message&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="@xqx:prefix"&gt;
            &lt;xsl:value-of select="@xqx:prefix"/&gt;
            &lt;xsl:value-of select="$COLON"/&gt;
            &lt;xsl:value-of select="."/&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:when test="@xqx:URI"&gt;
            &lt;xsl:text&gt;Q&lt;/xsl:text&gt;
            &lt;xsl:value-of select="$LBRACE"/&gt;
            &lt;xsl:value-of select="@xqx:URI"/&gt;
            &lt;xsl:value-of select="$RBRACE"/&gt;
            &lt;xsl:value-of select="."/&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;xsl:value-of select="."/&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:attributeName"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@xqx:prefix='xmlns'"&gt;
        &lt;xsl:message terminate="yes"&gt;Incorrect XQueryX: Attribute names are not permitted to have prefix 'xmlns'; use xqx:namespaceDeclaration to declare namespaces&lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test=". = 'xmlns'"&gt;
        &lt;xsl:message terminate="yes"&gt;Incorrect XQueryX: Attribute names are not permitted to be 'xmlns'; use xqx:namespaceDeclaration to declare namespaces&lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:call-template name="renderQName"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:NCName"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:rootExpr"&gt;
    &lt;xsl:value-of select="$SLASH"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:argumentPlaceholder"&gt;
    &lt;xsl:value-of select="$QUESTIONMARK"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:pathExpr/xqx:rootExpr"&gt;
    &lt;xsl:if test="not(following-sibling::xqx:stepExpr)"&gt;
      &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$SLASH"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:if test="not(following-sibling::xqx:stepExpr)"&gt;
      &lt;xsl:value-of select="$RPAREN"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:contextItemExpr"&gt;
    &lt;xsl:value-of select="$DOT"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:stringConstantExpr | xqx:stringLiteral"&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:value"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


<phrase diff="chg" at="2014-07-14">&lt;!-- 2016-09-23/JS Bug 29823 - Removed integerLiteral --&gt;
&lt;!-- 2014-08-28/JM Added integerLiteral for use in lookup (formerly mapLookup) --&gt;
  &lt;xsl:template match="xqx:integerConstantExpr |
</phrase>                       xqx:decimalConstantExpr |
                       xqx:doubleConstantExpr"&gt;
    &lt;xsl:value-of select="xqx:value"/&gt;
  &lt;/xsl:template&gt;


<phrase diff="chg" at="2014-07-14">&lt;!-- 2016-09-23/JS Bug 29823 - Removed variableRef --&gt;
&lt;!-- 2014-07-13/JM Added variiableRef for use in arrowExpr --&gt;
  &lt;xsl:template match="xqx:varRef"&gt;
</phrase>    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:apply-templates select="xqx:name"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:pragma"&gt;
    &lt;xsl:value-of select="$PRAGMA_BEGIN"/&gt;
    &lt;xsl:apply-templates select="xqx:pragmaName"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="xqx:pragmaContents"/&gt;
    &lt;xsl:value-of select="$PRAGMA_END"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:extensionExpr"&gt;
    &lt;xsl:apply-templates select="xqx:pragma"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:simpleMapExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:pathExpr[1]"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
    &lt;xsl:for-each select="xqx:pathExpr[position() != 1]"&gt;
      &lt;xsl:value-of select="$NEWLINE"/&gt;
      &lt;xsl:value-of select="$EXCLAMATIONMARK"/&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
      &lt;xsl:value-of select="$LPAREN"/&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
      &lt;xsl:value-of select="$RPAREN"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:functionCallExpr"&gt;
    &lt;xsl:if test="(xqx:functionName = 'node' or
                   xqx:functionName = 'document-node' or
                   xqx:functionName = 'element' or
                   xqx:functionName = 'attribute' or
                   xqx:functionName = 'schema-element' or
                   xqx:functionName = 'schema-attribute' or
                   xqx:functionName = 'processing-instruction' or
                   xqx:functionName = 'comment' or
                   xqx:functionName = 'text' or
                   xqx:functionName = 'function' or
                   xqx:functionName = 'namespace-node' or
                   xqx:functionName = 'item' or
                   xqx:functionName = 'if' or
                   xqx:functionName = 'switch' or
                   xqx:functionName = 'typeswitch' or
                   xqx:functionName = 'empty-sequence') and
                   ((not(xqx:functionName/@xqx:prefix) and not(xqx:functionName/@xqx:URI)) or
                    xqx:functionName/@xqx:prefix = '' or
                    xqx:functionName/@xqx:URI = '')"&gt;
      &lt;xsl:variable name="message"&gt;&lt;xsl:text&gt;Incorrect XQueryX: function calls must not use unqualified "reserved" name "&lt;/xsl:text&gt;&lt;xsl:value-of select="xqx:functionName"/&gt;&lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
      &lt;xsl:message terminate="yes"&gt;&lt;xsl:value-of select="$message"/&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates select="xqx:functionName"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:arguments"&gt;
        &lt;xsl:for-each select="xqx:arguments"&gt;
          &lt;xsl:call-template name="parenthesizedList"/&gt;
        &lt;/xsl:for-each&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$LPAREN"/&gt;
        &lt;xsl:value-of select="$RPAREN"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:constructorFunctionExpr"&gt;
    &lt;xsl:apply-templates select="xqx:typeName"/&gt;
    &lt;xsl:for-each select="xqx:argExpr"&gt;
      &lt;xsl:call-template name="parenthesizedList"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:unaryMinusOp | xqx:unaryPlusOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:unaryPlusOp"&gt;&lt;xsl:value-of select="$PLUS"/&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:unaryMinusOp"&gt;&lt;xsl:value-of select="$MINUS"/&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:operand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:addOp | xqx:subtractOp | xqx:multiplyOp
                     | xqx:divOp | xqx:idivOp | xqx:modOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:addOp"&gt;&lt;xsl:value-of select="$PLUS"/&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:subtractOp"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$MINUS"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:multiplyOp"&gt;&lt;xsl:value-of select="$STAR"/&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:divOp"&gt;&lt;xsl:text&gt; div &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:idivOp"&gt;&lt;xsl:text&gt; idiv &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:modOp"&gt;&lt;xsl:text&gt; mod &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:stringConcatenateOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:value-of select="$CONCATENATE"/&gt;
     &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:eqOp | xqx:neOp | xqx:ltOp
                     | xqx:gtOp | xqx:leOp | xqx:geOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:eqOp"&gt;&lt;xsl:text&gt; eq &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:neOp"&gt;&lt;xsl:text&gt; ne &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:ltOp"&gt;&lt;xsl:text&gt; lt &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:gtOp"&gt;&lt;xsl:text&gt; gt &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:leOp"&gt;&lt;xsl:text&gt; le &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:geOp"&gt;&lt;xsl:text&gt; ge &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:equalOp | xqx:notEqualOp | xqx:lessThanOp
                     | xqx:greaterThanOp | xqx:lessThanOrEqualOp | xqx:greaterThanOrEqualOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:equalOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$EQUAL"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:notEqualOp"&gt;
         &lt;xsl:text&gt; !&lt;/xsl:text&gt;&lt;xsl:value-of select="$EQUAL"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:lessThanOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$LESSTHAN"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:greaterThanOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$GREATERTHAN"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:lessThanOrEqualOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$LESSTHAN"/&gt;
         &lt;xsl:value-of select="$EQUAL"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:greaterThanOrEqualOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$GREATERTHAN"/&gt;
         &lt;xsl:value-of select="$EQUAL"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:isOp | xqx:nodeBeforeOp | xqx:nodeAfterOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:isOp"&gt;&lt;xsl:text&gt; is &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:nodeBeforeOp"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
         &lt;xsl:value-of select="$LESSTHAN"/&gt;&lt;xsl:value-of select="$LESSTHAN"/&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:nodeAfterOp"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
         &lt;xsl:value-of select="$GREATERTHAN"/&gt;&lt;xsl:value-of select="$GREATERTHAN"/&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:andOp | xqx:orOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:andOp"&gt;&lt;xsl:text&gt; and &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:orOp"&gt;&lt;xsl:text&gt; or &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:unionOp | xqx:intersectOp | xqx:exceptOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:unionOp"&gt;&lt;xsl:text&gt; union &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:intersectOp"&gt;&lt;xsl:text&gt; intersect &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:exceptOp"&gt;&lt;xsl:text&gt; except &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:sequenceExpr"&gt;
    &lt;xsl:for-each select="."&gt;
      &lt;xsl:call-template name="parenthesizedList"&gt;
        &lt;xsl:with-param name="delimiter" select="$COMMA_NEWLINE"/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:rangeSequenceExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:startExpr"/&gt;
    &lt;xsl:value-of select="$TO"/&gt;
    &lt;xsl:apply-templates select="xqx:endExpr"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:forClause"&gt;
    &lt;xsl:text&gt; for &lt;/xsl:text&gt;
    &lt;xsl:call-template name="commaSeparatedList"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:forClauseItem"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:allowingEmpty"&gt;
    &lt;xsl:text&gt; allowing empty &lt;/xsl:text&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:forExpr"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;    in &lt;/xsl:text&gt;
        &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:letClause"&gt;
    &lt;xsl:text&gt; let &lt;/xsl:text&gt;
    &lt;xsl:call-template name="commaSeparatedList"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:letClauseItem"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:letExpr"&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$ASSIGN"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:windowClause"&gt;
    &lt;xsl:text&gt; for &lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:tumblingWindowClause"&gt;
    &lt;xsl:text&gt;   tumbling window &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:typedVariableBinding"/&gt;
    &lt;xsl:text&gt; in &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:bindingSequence"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;      &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:windowStartCondition"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;      &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:windowEndCondition"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:slidingWindowClause"&gt;
    &lt;xsl:text&gt;   sliding window &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:typedVariableBinding"/&gt;
    &lt;xsl:text&gt; in &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:bindingSequence"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;      &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:windowStartCondition"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;      &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:windowEndCondition"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:bindingSequence"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:windowStartCondition"&gt;
    &lt;xsl:text&gt;start &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:windowVars"/&gt;
    &lt;xsl:text&gt; when &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:winStartExpr"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:windowEndCondition"&gt;
    &lt;xsl:if test="@xqx:onlyEnd='true'"&gt;
      &lt;xsl:text&gt;only &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:text&gt;end &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:windowVars"/&gt;
    &lt;xsl:text&gt; when &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:winEndExpr"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:windowVars"&gt;
    &lt;xsl:apply-templates select="xqx:currentItem"/&gt;
    &lt;xsl:apply-templates select="xqx:positionalVariableBinding"/&gt;
    &lt;xsl:apply-templates select="xqx:previousItem"/&gt;
    &lt;xsl:apply-templates select="xqx:nextItem"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:currentItem"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:call-template name="renderEQName"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:previousItem"&gt;
    &lt;xsl:text&gt; previous &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:call-template name="renderEQName"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:nextItem"&gt;
    &lt;xsl:text&gt; next &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:call-template name="renderEQName"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:countClause"&gt;
    &lt;xsl:text&gt; count &lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:whereClause"&gt;
    &lt;xsl:text&gt; where &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:groupByClause"&gt;
    &lt;xsl:text&gt;  group by &lt;/xsl:text&gt;
    &lt;xsl:call-template name="commaSeparatedList"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:groupingSpec"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:groupVarInitialize"&gt;
    &lt;xsl:if test="xqx:typeDeclaration"&gt;
      &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$ASSIGN"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:varValue"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:collation"&gt;
    &lt;xsl:text&gt; collation &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item"&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:emptyOrderingMode"&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderingKind"&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderModifier"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderBySpec"&gt;
    &lt;xsl:apply-templates select="xqx:orderByExpr"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:orderModifier"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderByClause"&gt;
    &lt;xsl:if test="xqx:stable"&gt;
      &lt;xsl:text&gt; stable&lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:text&gt; order by &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:orderBySpec[1]"/&gt;
    &lt;xsl:for-each select="xqx:orderBySpec[position() &gt; 1]"&gt;
      &lt;xsl:value-of select="$COMMA_SPACE"/&gt;
      &lt;xsl:apply-templates select="."/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:returnClause"&gt;
    &lt;xsl:text&gt; return &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


&lt;!-- Surrounding FLWOR expressions with parentheses completes the set --&gt;
  &lt;xsl:template match="xqx:flworExpr"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:ifThenElseExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:text&gt; if &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:ifClause"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
    &lt;xsl:text&gt; then &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:thenClause"/&gt;
    &lt;xsl:text&gt; else &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:elseClause"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:positionalVariableBinding"&gt;
    &lt;xsl:text&gt; at &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:call-template name="renderEQName"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:variableBinding"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:call-template name="renderEQName"/&gt;
    &lt;xsl:if test="parent::xqx:typeswitchExprCaseClause"&gt;
      &lt;xsl:text&gt; as &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typedVariableBinding" name="typedVariableBinding"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:apply-templates select="xqx:varName"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:quantifiedExprInClause"&gt;
    &lt;xsl:apply-templates select="xqx:typedVariableBinding"/&gt;
    &lt;xsl:text&gt; in &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:sourceExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:quantifiedExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:value-of select="xqx:quantifier"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:quantifiedExprInClause[1]"/&gt;
    &lt;xsl:for-each select="xqx:quantifiedExprInClause[position() &gt; 1]"&gt;
      &lt;xsl:value-of select="$COMMA_SPACE"/&gt;
      &lt;xsl:apply-templates select="."/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:text&gt; satisfies &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:predicateExpr"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:instanceOfExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:text&gt; instance of &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:sequenceType"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:castExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:text&gt; cast as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:singleType"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


<phrase diff="add" at="2015-02-11">&lt;!-- 2015-02-11/JM For new expr arrowExpr --&gt;
&lt;!-- 2016-11-01/JS does not always convert arrowExpr to XQuery correctly --&gt;
  &lt;xsl:template match="xqx:arrowExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:for-each select="*[not(self::xqx:argExpr) and not(self::xqx:arguments)]"&gt;
      &lt;xsl:text&gt; =&amp;gt; &lt;/xsl:text&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="self::xqx:EQName or self::xqx:variableRef"&gt;
          &lt;xsl:apply-templates select="."/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:value-of select="$LPAREN"/&gt;
          &lt;xsl:apply-templates select="."/&gt;
          &lt;xsl:value-of select="$RPAREN"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="following-sibling::*[1][self::xqx:arguments]"&gt;
          &lt;xsl:for-each select="following-sibling::*[1][self::xqx:arguments]"&gt;
            &lt;xsl:call-template name="parenthesizedList"/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:value-of select="$LPAREN"/&gt;
          &lt;xsl:value-of select="$RPAREN"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


</phrase>  &lt;xsl:template match="xqx:castableExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:text&gt; castable as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:singleType"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:treatExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:text&gt; treat as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:sequenceType"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:switchExprCaseClause"&gt;
    &lt;xsl:for-each select="xqx:switchCaseExpr"&gt;
      &lt;xsl:value-of select="$NEWLINE"/&gt;
      &lt;xsl:text&gt;   case (&lt;/xsl:text&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:text&gt;) &lt;/xsl:text&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;     return &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:resultExpr"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:switchExprDefaultClause"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;   default return &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:resultExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:switchExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:text&gt;switch&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:switchExprCaseClause"/&gt;
    &lt;xsl:apply-templates select="xqx:switchExprDefaultClause"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typeswitchExprCaseClause"&gt;
    &lt;xsl:text&gt; case &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:variableBinding"/&gt;
    &lt;xsl:apply-templates select="xqx:sequenceType | xqx:sequenceTypeUnion"/&gt;
    &lt;xsl:text&gt; return &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:resultExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typeswitchExprDefaultClause"&gt;
    &lt;xsl:text&gt; default &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:variableBinding"/&gt;
    &lt;xsl:text&gt; return &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:resultExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typeswitchExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:text&gt;typeswitch&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:typeswitchExprCaseClause"/&gt;
    &lt;xsl:apply-templates select="xqx:typeswitchExprDefaultClause"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:tryCatchExpr"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:text&gt;try &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:tryClause"/&gt;
    &lt;xsl:apply-templates select="xqx:catchClause"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:tryClause"&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:catchClause"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;  catch &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:catchErrorList"/&gt;
    &lt;xsl:apply-templates select="xqx:catchExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:catchErrorList"&gt;
    &lt;xsl:for-each select="xqx:nameTest | xqx:Wildcard"&gt;
      &lt;xsl:if test="(position() mod 5) = 0"&gt;
        &lt;xsl:value-of select="$NEWLINE"/&gt;
        &lt;xsl:text&gt;      &lt;/xsl:text&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:if test="position() &gt; 1"&gt;
        &lt;xsl:text&gt;| &lt;/xsl:text&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:catchExpr"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:validateExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:text&gt; validate &lt;/xsl:text&gt;
    &lt;xsl:if test="xqx:validationMode"&gt;
      &lt;xsl:value-of select="xqx:validationMode"/&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:typeName"&gt;
      &lt;xsl:text&gt;type &lt;/xsl:text&gt;
      &lt;xsl:apply-templates select="xqx:typeName"/&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:xpathAxis"&gt;
    &lt;xsl:value-of select="."/&gt;
    &lt;xsl:value-of select="$DOUBLE_COLON"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:predicates"&gt;
    &lt;xsl:for-each select="*"&gt;
      &lt;xsl:value-of select="$LBRACKET"/&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:value-of select="$RBRACKET"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


<phrase diff="add" at="2014-07-14">&lt;!-- 2014-07-13/JM Used in revised stepExpr to support new alternatives lookup (formerly mapLookup) --&gt;
  &lt;xsl:template match="xqx:predicate"&gt;
    &lt;xsl:value-of select="$LBRACKET"/&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:value-of select="$RBRACKET"/&gt;
  &lt;/xsl:template&gt;


</phrase>  &lt;!-- part of higher-order functions --&gt;
  &lt;xsl:template match="xqx:dynamicFunctionInvocationExpr"&gt;
    &lt;xsl:apply-templates select="xqx:functionItem"/&gt;
    &lt;xsl:apply-templates select="xqx:predicates"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:arguments"&gt;
        &lt;xsl:for-each select="xqx:arguments"&gt;
          &lt;xsl:call-template name="parenthesizedList"/&gt;
        &lt;/xsl:for-each&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$LPAREN"/&gt;
        &lt;xsl:value-of select="$RPAREN"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;!-- part of higher-order functions --&gt;
  &lt;xsl:template match="xqx:functionItem"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;


<phrase diff="add" at="2014-07-14">&lt;!-- 2014-07-13/JM Added mapConstructor                                                 --&gt;
  &lt;xsl:template match="xqx:mapConstructor"&gt;
     &lt;xsl:text&gt;map { &lt;/xsl:text&gt;
     &lt;xsl:apply-templates select="xqx:mapConstructorEntry[1]"/&gt;
     &lt;xsl:if test="xqx:mapConstructorEntry[2]"&gt;
       &lt;xsl:for-each select="xqx:mapConstructorEntry[position() &gt; 1]"&gt;
         &lt;xsl:text&gt; , &lt;/xsl:text&gt;
         &lt;xsl:apply-templates select="."/&gt;
       &lt;/xsl:for-each&gt;
     &lt;/xsl:if&gt;
     &lt;xsl:text&gt; } &lt;/xsl:text&gt;
  &lt;/xsl:template&gt;

&lt;!-- 2014-07-13/JM Added mapConstructorEntry                                            --&gt;
  &lt;xsl:template match="xqx:mapConstructorEntry"&gt;
    &lt;xsl:apply-templates select="*[1]"/&gt;
    &lt;xsl:text&gt; : &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*[2]"/&gt;
  &lt;/xsl:template&gt;


&lt;!-- 2014-07-13/JM Added arrayConstructor                                               --&gt;
  &lt;xsl:template match="xqx:arrayConstructor"&gt;
   &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;


&lt;!-- 2014-07-13/JM Added squareArray                                                    --&gt;
  &lt;xsl:template match="xqx:squareArray"&gt;
    &lt;xsl:text&gt; [ &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:arrayElem[1]"/&gt;
    &lt;xsl:if test="xqx:arrayElem[2]"&gt;
      &lt;xsl:for-each select="xqx:arrayElem[position() &gt; 1]"&gt;
        &lt;xsl:text&gt; , &lt;/xsl:text&gt;
        &lt;xsl:apply-templates select="."/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:text&gt; ] &lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


&lt;!-- 2014-07-13/JM Added curlyArray                                                    --&gt;
  &lt;xsl:template match="xqx:curlyArray"&gt;
    &lt;xsl:text&gt; array { &lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:text&gt; } &lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


</phrase><phrase diff="add" at="2015-11-05">&lt;!-- 2015-11-05/JS Added stringConstructor                                                 --&gt;
  &lt;xsl:template match="xqx:stringConstructor"&gt;
    &lt;xsl:text&gt;``[&lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:text&gt;]``&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;

&lt;!-- 2015-11-05/JS Added stringConstructorInterpolation                                --&gt;
  &lt;xsl:template match="xqx:stringConstructorInterpolation"&gt;
    &lt;xsl:text&gt;`{&lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:text&gt;}`&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;

&lt;!-- 2015-11-05/JS Added stringConstructorChars                                        --&gt;
  &lt;xsl:template match="xqx:stringConstructorChars"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


</phrase>  &lt;xsl:template match="xqx:star"&gt;
    &lt;xsl:value-of select="$STAR"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:Wildcard[*]"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="local-name(./child::*[1])='star'"&gt;
        &lt;xsl:apply-templates select="xqx:star"/&gt;
        &lt;xsl:value-of select="$COLON"/&gt;
        &lt;xsl:apply-templates select="xqx:NCName"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="local-name(./child::*[1])='NCName'"&gt;
        &lt;xsl:apply-templates select="xqx:NCName"/&gt;
        &lt;xsl:value-of select="$COLON"/&gt;
        &lt;xsl:apply-templates select="xqx:star"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="local-name(./child::*[1])='uri'"&gt;
        &lt;xsl:text&gt;Q&lt;/xsl:text&gt;
        &lt;xsl:value-of select="$LBRACE"/&gt;
        &lt;xsl:value-of select="./xqx:uri"/&gt;
        &lt;xsl:value-of select="$RBRACE"/&gt;
        &lt;xsl:apply-templates select="xqx:star"/&gt;
      &lt;/xsl:when&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:Wildcard[not(*)]"&gt;
    &lt;xsl:value-of select="$STAR"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template name="simpleWildcard" match="xqx:simpleWildcard"&gt;
    &lt;xsl:apply-templates select="xqx:star"/&gt;
    &lt;xsl:apply-templates select="xqx:QName"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:textTest"&gt;
    &lt;xsl:text&gt;text()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:commentTest"&gt;
    &lt;xsl:text&gt;comment()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:namespaceTest"&gt;
    &lt;xsl:text&gt;namespace-node()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:anyKindTest"&gt;
    &lt;xsl:text&gt;node()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:piTest"&gt;
    &lt;xsl:text&gt;processing-instruction&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:value-of select="*"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:documentTest"&gt;
    &lt;xsl:text&gt;document-node&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:nameTest"&gt;
    &lt;xsl:call-template name="renderEQName"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:attributeTest"&gt;
    &lt;xsl:text&gt;attribute&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:for-each select="xqx:attributeName"&gt;
      &lt;xsl:call-template name="simpleWildcard"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:if test="xqx:typeName"&gt;
      &lt;xsl:value-of select="$COMMA"/&gt;
      &lt;xsl:apply-templates select="xqx:typeName"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:elementTest"&gt;
    &lt;xsl:text&gt;element&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:for-each select="xqx:elementName"&gt;
      &lt;xsl:call-template name="simpleWildcard"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:if test="xqx:typeName"&gt;
      &lt;xsl:value-of select="$COMMA"/&gt;
      &lt;xsl:apply-templates select="xqx:typeName"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:nillable"&gt;
      &lt;xsl:value-of select="$QUESTIONMARK"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:schemaElementTest"&gt;
    &lt;xsl:text&gt;schema-element&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:call-template name="renderEQName"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:schemaAttributeTest"&gt;
    &lt;xsl:text&gt;schema-attribute&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:call-template name="renderEQName"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;!-- anyFunctionTest, part of higher-order functions --&gt;
  &lt;xsl:template match="xqx:anyFunctionTest"&gt;
    &lt;xsl:apply-templates select="xqx:annotation"/&gt;
    &lt;xsl:text&gt; function(*)&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;!-- typedFunctionTest, part of higher-order functions --&gt;
  &lt;xsl:template match="xqx:typedFunctionTest"&gt;
    &lt;xsl:apply-templates select="xqx:annotation"/&gt;
    &lt;xsl:text&gt; function&lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:paramTypeList"/&gt;
    &lt;xsl:text&gt; as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:sequenceType"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:paramTypeList"&gt;
    &lt;xsl:call-template name="parenthesizedList"/&gt;
  &lt;/xsl:template&gt;


<phrase diff="add" at="2014-07-14">&lt;!-- 2014-07-11/JM For new MapTest --&gt;
  &lt;xsl:template match="xqx:anyMapTest"&gt;
    &lt;xsl:text&gt; map(*)&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


&lt;!-- 2014-07-11/JM For new MapTest --&gt;
  &lt;xsl:template match="xqx:typedMapTest"&gt;
    &lt;xsl:text&gt; map(&lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:atomicType"/&gt;
    &lt;xsl:text&gt;, &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:sequenceType"/&gt;
    &lt;xsl:text&gt;) &lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


&lt;!-- 2014-07-13/JM For new stepExpr alternative lookup (formerly mapLookup) --&gt;
&lt;!-- 2016-01-20/JS Add support for unaryLookup (bug 29364) --&gt;
&lt;!-- 2016-09-23/JS Bug 29823 - Renamed integerLiteral to integerConstantExpr  --&gt;
  &lt;xsl:template match="xqx:lookup | xqx:unaryLookup"&gt;
    &lt;xsl:text&gt; ?&lt;/xsl:text&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:star | xqx:NCName | xqx:integerConstantExpr"&gt;
        &lt;xsl:apply-templates/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$LPAREN"/&gt;
        &lt;xsl:apply-templates/&gt;
	&lt;xsl:value-of select="$RPAREN"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;

&lt;!-- 2014-07-11/JM For new ArrayTest --&gt;
  &lt;xsl:template match="xqx:anyArrayTest"&gt;
    &lt;xsl:text&gt; array(*)&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


&lt;!-- 2014-07-11/JM For new ArrayTest --&gt;
  &lt;xsl:template match="xqx:typedArrayTest"&gt;
    &lt;xsl:text&gt; array(&lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:sequenceType"/&gt;
    &lt;xsl:text&gt;) &lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


</phrase>  &lt;!-- parenthesizedItemType, part of higher-order functions --&gt;
  &lt;xsl:template match="xqx:parenthesizedItemType"&gt;
    &lt;xsl:text&gt; ( &lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:text&gt; ) &lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:stepExpr"&gt;
    &lt;xsl:if test="preceding-sibling::xqx:stepExpr"&gt;
      &lt;xsl:value-of select="$SLASH"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:filterExpr"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;


  &lt;!-- part of higher-order functions --&gt;
  &lt;xsl:template match="xqx:namedFunctionRef"&gt;
    &lt;xsl:if test="(xqx:functionName = 'node' or
                   xqx:functionName = 'document-node' or
                   xqx:functionName = 'element' or
                   xqx:functionName = 'attribute' or
                   xqx:functionName = 'schema-element' or
                   xqx:functionName = 'schema-attribute' or
                   xqx:functionName = 'processing-instruction' or
                   xqx:functionName = 'comment' or
                   xqx:functionName = 'text' or
                   xqx:functionName = 'function' or
                   xqx:functionName = 'namespace-node' or
                   xqx:functionName = 'item' or
                   xqx:functionName = 'if' or
                   xqx:functionName = 'switch' or
                   xqx:functionName = 'typeswitch' or
                   xqx:functionName = 'empty-sequence') and
                   ((not(@xqx:prefix) and not(@xqx:URI)) or
                    (@xqx:prefix and @xqx:prefix = '') or
                    (@xqx:URI and @xqx:URI = ''))"&gt;
      &lt;xsl:variable name="message"&gt;&lt;xsl:text&gt;Incorrect XQueryX: function calls must not use unqualified "reserved" name "&lt;/xsl:text&gt;&lt;xsl:value-of select="xqx:functionName"/&gt;&lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
      &lt;xsl:message terminate="yes"&gt;&lt;xsl:value-of select="$message"/&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates select="xqx:functionName"/&gt;
    &lt;xsl:text&gt;#&lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:integerConstantExpr"/&gt;
  &lt;/xsl:template&gt;

  &lt;!-- part of higher-order functions --&gt;
  &lt;xsl:template match="xqx:inlineFunctionExpr"&gt;
    &lt;xsl:apply-templates select="xqx:annotation"/&gt;
    &lt;xsl:text&gt; function &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:paramList"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
    &lt;xsl:apply-templates select="xqx:functionBody"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:pathExpr"&gt;
    &lt;xsl:apply-templates select="xqx:rootExpr | xqx:stepExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:attributeConstructor"&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:attributeName"/&gt;
    &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:attributeValue"&gt;
        &lt;xsl:call-template name="globalReplace"&gt;
          &lt;xsl:with-param name="stringToBeFixed"&gt;
            &lt;xsl:call-template name="globalReplace"&gt;
              &lt;xsl:with-param name="stringToBeFixed"&gt;
                &lt;xsl:call-template name="quote"&gt;
                  &lt;xsl:with-param name="item"&gt;
                    &lt;xsl:call-template name="globalReplace"&gt;
                      &lt;xsl:with-param name="stringToBeFixed"&gt;
                        &lt;xsl:call-template name="globalReplace"&gt;
                          &lt;xsl:with-param name="stringToBeFixed"&gt;
                            &lt;xsl:value-of select="xqx:attributeValue"/&gt;
                          &lt;/xsl:with-param&gt;
                          &lt;xsl:with-param name="toBeReplaced"&gt;&lt;xsl:text&gt;{&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
                          &lt;xsl:with-param name="replacement"&gt;&lt;xsl:text&gt;{{&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
                        &lt;/xsl:call-template&gt;
                      &lt;/xsl:with-param&gt;
                      &lt;xsl:with-param name="toBeReplaced"&gt;&lt;xsl:text&gt;}&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
                      &lt;xsl:with-param name="replacement"&gt;&lt;xsl:text&gt;}}&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
                    &lt;/xsl:call-template&gt;
                  &lt;/xsl:with-param&gt;
                &lt;/xsl:call-template&gt;
              &lt;/xsl:with-param&gt;
              &lt;xsl:with-param name="toBeReplaced" select="'&amp;#xA;'"/&gt;
              &lt;xsl:with-param name="replacement"&gt;&amp;amp;#xA;&lt;/xsl:with-param&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="toBeReplaced" select="'&amp;#x9;'"/&gt;
          &lt;xsl:with-param name="replacement"&gt;&amp;amp;#x9;&lt;/xsl:with-param&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$DOUBLEQUOTE"/&gt;
        &lt;xsl:for-each select="./xqx:attributeValueExpr/xqx:*"&gt;
          &lt;xsl:value-of select="$LBRACE"/&gt;
            &lt;xsl:apply-templates select="."/&gt;
          &lt;xsl:value-of select="$RBRACE"/&gt;
        &lt;/xsl:for-each&gt;
        &lt;xsl:value-of select="$DOUBLEQUOTE"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:namespaceDeclaration"&gt;
    &lt;xsl:text&gt; xmlns&lt;/xsl:text&gt;
    &lt;xsl:if test="xqx:prefix"&gt;
      &lt;xsl:text&gt;:&lt;/xsl:text&gt;
      &lt;xsl:value-of select="xqx:prefix"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;xsl:call-template name="quote"&gt;
       &lt;xsl:with-param name="item"&gt;
         &lt;xsl:call-template name="globalReplace"&gt;
           &lt;xsl:with-param name="stringToBeFixed"&gt;
             &lt;xsl:call-template name="globalReplace"&gt;
               &lt;xsl:with-param name="stringToBeFixed"&gt;
                 &lt;xsl:value-of select="xqx:uri"/&gt;
               &lt;/xsl:with-param&gt;
               &lt;xsl:with-param name="toBeReplaced"&gt;
                 &lt;xsl:text&gt;{&lt;/xsl:text&gt;
               &lt;/xsl:with-param&gt;
               &lt;xsl:with-param name="replacement"&gt;
                 &lt;xsl:text&gt;{{&lt;/xsl:text&gt;
               &lt;/xsl:with-param&gt;
             &lt;/xsl:call-template&gt;
           &lt;/xsl:with-param&gt;
           &lt;xsl:with-param name="toBeReplaced"&gt;
             &lt;xsl:text&gt;}&lt;/xsl:text&gt;
           &lt;/xsl:with-param&gt;
           &lt;xsl:with-param name="replacement"&gt;
             &lt;xsl:text&gt;}}&lt;/xsl:text&gt;
           &lt;/xsl:with-param&gt;
         &lt;/xsl:call-template&gt;
       &lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:attributeList"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:elementContent"&gt;
    &lt;xsl:for-each select="*"&gt;
      &lt;xsl:if test="not(self::xqx:elementConstructor)"&gt;
        &lt;xsl:value-of select="$SPACE"/&gt;
        &lt;xsl:value-of select="$LBRACE"/&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:if test="not(self::xqx:elementConstructor)"&gt;
        &lt;xsl:value-of select="$SPACE"/&gt;
        &lt;xsl:value-of select="$RBRACE"/&gt;
      &lt;/xsl:if&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:elementConstructor"&gt;
    &lt;xsl:value-of select="$LESSTHAN"/&gt;
    &lt;xsl:apply-templates select="xqx:tagName"/&gt;
    &lt;xsl:apply-templates select="xqx:attributeList"/&gt;
    &lt;xsl:value-of select="$GREATERTHAN"/&gt;
    &lt;xsl:apply-templates select="xqx:elementContent"/&gt;
    &lt;xsl:value-of select="$LESSTHAN"/&gt;
    &lt;xsl:value-of select="$SLASH"/&gt;
    &lt;xsl:apply-templates select="xqx:tagName"/&gt;
    &lt;xsl:value-of select="$GREATERTHAN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:tagNameExpr"&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedElementConstructor"&gt;
    &lt;xsl:text&gt; element &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:tagName"/&gt;
    &lt;xsl:apply-templates select="xqx:tagNameExpr"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:contentExpr"/&gt;     
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:contentExpr"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:computedAttributeConstructor"&gt;
    &lt;xsl:text&gt; attribute &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:tagName"/&gt;
    &lt;xsl:apply-templates select="xqx:tagNameExpr"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:valueExpr"/&gt;     
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedDocumentConstructor"&gt;
    &lt;xsl:text&gt; document {&lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:text&gt; }&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedTextConstructor"&gt;
    &lt;xsl:text&gt; text&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedCommentConstructor"&gt;
    &lt;xsl:text&gt; comment&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedNamespaceConstructor"&gt;
    &lt;xsl:text&gt; namespace &lt;/xsl:text&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:prefix"&gt;
        &lt;xsl:value-of select="xqx:prefix"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$LBRACE"/&gt;
        &lt;xsl:apply-templates select="xqx:prefixExpr"/&gt;
        &lt;xsl:value-of select="$RBRACE"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:URIExpr"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:piTargetExpr"&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:piValueExpr"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedPIConstructor"&gt;
    &lt;xsl:text&gt; processing-instruction &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:piTarget"/&gt;
    &lt;xsl:apply-templates select="xqx:piTargetExpr"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:piValueExpr"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:unorderedExpr"&gt;
    &lt;xsl:text&gt; unordered&lt;/xsl:text&gt;
        &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderedExpr"&gt;
    &lt;xsl:text&gt; ordered&lt;/xsl:text&gt;
        &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:versionDecl"&gt;
    &lt;xsl:text&gt;xquery &lt;/xsl:text&gt;
    &lt;xsl:if test="xqx:version"&gt;
      &lt;xsl:text&gt;version &lt;/xsl:text&gt;
      &lt;xsl:call-template name="quote"&gt;
        &lt;xsl:with-param name="item" select="xqx:version"/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:encoding and xqx:version"&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:encoding"&gt;
      &lt;xsl:text&gt;encoding &lt;/xsl:text&gt;
      &lt;xsl:call-template name="quote"&gt;
        &lt;xsl:with-param name="item" select="xqx:encoding"/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$SEPARATOR"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:namespaceDecl"&gt;
    &lt;xsl:text&gt;declare namespace &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:prefix"/&gt;
    &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:uri"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:defaultNamespaceDecl"&gt;
    &lt;xsl:text&gt;declare default &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:defaultNamespaceCategory"/&gt;
    &lt;xsl:text&gt; namespace &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:uri"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:boundarySpaceDecl"&gt;
    &lt;xsl:text&gt;declare boundary-space &lt;/xsl:text&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:defaultCollationDecl"&gt;
    &lt;xsl:text&gt;declare default collation &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="."/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:baseUriDecl"&gt;
    &lt;xsl:text&gt;declare base-uri &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="."/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:constructionDecl"&gt;
    &lt;xsl:text&gt;declare construction &lt;/xsl:text&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderingModeDecl"&gt;
    &lt;xsl:text&gt;declare ordering &lt;/xsl:text&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:emptyOrderingDecl"&gt;
    &lt;xsl:text&gt;declare default order &lt;/xsl:text&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:copyNamespacesDecl"&gt;
    &lt;xsl:text&gt;declare copy-namespaces &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:preserveMode"/&gt;
    &lt;xsl:value-of select="$COMMA"/&gt;
    &lt;xsl:value-of select="xqx:inheritMode"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:optionDecl"&gt;
    &lt;xsl:text&gt;declare option &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:optionName"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:optionContents"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:decimalFormatDecl"&gt;
    &lt;xsl:text&gt;declare &lt;/xsl:text&gt;
    &lt;xsl:if test="not(xqx:decimalFormatName)"&gt;
      &lt;xsl:text&gt;default &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:text&gt;decimal-format &lt;/xsl:text&gt;
    &lt;xsl:if test="xqx:decimalFormatName"&gt;
      &lt;xsl:apply-templates select="xqx:decimalFormatName"/&gt;
      &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates select="xqx:decimalFormatParam"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:decimalFormatParam"&gt;
    &lt;xsl:value-of select="xqx:decimalFormatParamName"/&gt;
    &lt;xsl:text&gt; = &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:decimalFormatParamValue"/&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:voidSequenceType"&gt;
    &lt;xsl:text&gt;empty-sequence()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:occurrenceIndicator"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:anyItemType"&gt;
    &lt;xsl:text&gt;item()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:sequenceType"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:sequenceTypeUnion"&gt;
    &lt;xsl:apply-templates select="xqx:sequenceType[1]"/&gt;
    &lt;xsl:if test="count(xqx:sequenceType) &gt; 1"&gt;
      &lt;xsl:for-each select="xqx:sequenceType[position() &gt; 1]"&gt;
        &lt;xsl:text&gt; | &lt;/xsl:text&gt;
        &lt;xsl:apply-templates select="."/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:singleType"&gt;
    &lt;xsl:apply-templates select="xqx:atomicType"/&gt;
    &lt;xsl:if test="xqx:optional"&gt;
      &lt;xsl:text&gt;?&lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typeDeclaration"&gt;
    &lt;xsl:text&gt; as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


&lt;!-- contextItemDecl shouldn't have sequenceType, but itemType                         --&gt;
  &lt;xsl:template match="xqx:contextItemType"&gt;
    &lt;xsl:text&gt; as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


&lt;!-- contextItemDecl shouldn't have sequenceType, but itemType                         --&gt;
  &lt;xsl:template match="xqx:contextItemDecl"&gt;
    &lt;xsl:text&gt;declare context item &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:contextItemType"/&gt;
    &lt;xsl:if test="xqx:varValue"&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
      &lt;xsl:value-of select="$ASSIGN"/&gt;
      &lt;xsl:value-of select="$SPACE"/&gt;
      &lt;xsl:apply-templates select="xqx:varValue"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:external"&gt;
      &lt;xsl:text&gt; external &lt;/xsl:text&gt;
      &lt;xsl:if test="xqx:external/xqx:varValue"&gt;
        &lt;xsl:text&gt;:= &lt;/xsl:text&gt;
        &lt;xsl:apply-templates select="xqx:external/xqx:varValue"/&gt;
      &lt;/xsl:if&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:annotation"&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="$PERCENT"/&gt;
    &lt;xsl:apply-templates select="xqx:annotationName"/&gt;
    &lt;xsl:if test="xqx:arguments"&gt;
      &lt;xsl:for-each select="xqx:arguments"&gt;
         &lt;xsl:call-template name="parenthesizedList"/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:varDecl"&gt;
    &lt;xsl:text&gt;declare&lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:annotation"/&gt;
    &lt;xsl:text&gt; variable &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:apply-templates select="xqx:varName"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
    &lt;xsl:if test="xqx:varValue"&gt;
      &lt;xsl:value-of select="$ASSIGN"/&gt;
      &lt;xsl:apply-templates select="xqx:varValue"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:external"&gt;
      &lt;xsl:text&gt; external &lt;/xsl:text&gt;
      &lt;xsl:if test="xqx:external/xqx:varValue"&gt;
        &lt;xsl:text&gt;:= &lt;/xsl:text&gt;
        &lt;xsl:apply-templates select="xqx:external/xqx:varValue"/&gt;
      &lt;/xsl:if&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:targetLocation"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="position()=1"&gt; at &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;,&amp;#xD;  &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="."/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:schemaImport"&gt;
    &lt;xsl:text&gt; import schema &lt;/xsl:text&gt;
    &lt;xsl:if test="xqx:defaultElementNamespace"&gt;
      &lt;xsl:text&gt; default element namespace &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:namespacePrefix"&gt;
      &lt;xsl:text&gt; namespace &lt;/xsl:text&gt;
      &lt;xsl:value-of select="xqx:namespacePrefix"/&gt;
      &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:targetNamespace"/&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:apply-templates select="xqx:targetLocation"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:moduleImport"&gt;
    &lt;xsl:text&gt; import module &lt;/xsl:text&gt;
    &lt;xsl:if test="xqx:namespacePrefix"&gt;
      &lt;xsl:text&gt; namespace &lt;/xsl:text&gt;
      &lt;xsl:value-of select="xqx:namespacePrefix"/&gt;
      &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:targetNamespace"/&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:apply-templates select="xqx:targetLocation"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:param"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:apply-templates select="xqx:varName"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:paramList"&gt;
    &lt;xsl:call-template name="parenthesizedList"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:functionBody"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:functionDecl"&gt;
    &lt;xsl:text&gt;declare&lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:annotation"/&gt;
    &lt;xsl:text&gt; function &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:functionName"/&gt;
    &lt;xsl:apply-templates select="xqx:paramList"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:externalDefinition"&gt;
        &lt;xsl:text&gt; external &lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:apply-templates select="xqx:functionBody"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:queryBody"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:moduleDecl"&gt;
    &lt;xsl:text&gt; module namespace &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:prefix"/&gt;
    &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:uri" /&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:value-of select="$SEPARATOR"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:prolog"&gt;
    &lt;xsl:for-each select="*"&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:value-of select="$SEPARATOR"/&gt;
      &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:libraryModule"&gt;
    &lt;xsl:apply-templates select="xqx:moduleDecl"/&gt;
    &lt;xsl:apply-templates select="xqx:prolog"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:mainModule"&gt;
    &lt;xsl:apply-templates select="xqx:prolog"/&gt;
    &lt;xsl:apply-templates select="xqx:queryBody"/&gt;
  &lt;/xsl:template&gt;


&lt;!-- Enhanced to properly support encoding parameter --&gt;
  &lt;xsl:template match="xqx:module" priority="2"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:versionDecl/xqx:encoding"&gt;
        &lt;xsl:variable name="enc"&gt;
          &lt;xsl:value-of select='xqx:versionDecl/xqx:encoding'/&gt;
        &lt;/xsl:variable&gt;
        &lt;xsl:result-document encoding="{$enc}"&gt;
          &lt;xsl:apply-templates select="*"/&gt;
          &lt;xsl:fallback&gt;
            &lt;xsl:apply-templates select="*"/&gt;
          &lt;/xsl:fallback&gt;
        &lt;/xsl:result-document&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:apply-templates select="*"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="/xqx:*"&gt;
   &lt;xsl:message terminate="yes"&gt;Incorrect XQueryX: The only top-level element permitted is xqx:module&lt;/xsl:message&gt;
  &lt;/xsl:template&gt;


&lt;/xsl:stylesheet&gt;

</eg></div1><!-- Insert the appendix for the MIME type for XQueryX here --><div1 role="xqueryx" id="xqueryx-id-mime-type"><head>The <code>application/xquery+xml</code> Media Type</head><p>This Appendix specifies the media type for <phrase diff="chg" at="2014-04-24">XQueryX Version 3.1</phrase>. 
     XQueryX is the XML syntax of a language, XQuery, for querying over
     data from XML data sources, as specified in <phrase diff="chg" at="2014-04-24">
               <bibref ref="xquery-31"/>
            </phrase>.</p><note><p>Specification of media types is described in
           <bibref ref="RFC3023"/>.</p></note><div2 id="xqueryx-mime-introduction"><head>Introduction</head><p>This document, together with its normative references, defines the
       XML syntax for the XML Query language <phrase diff="chg" at="2014-04-24">XQuery Version 3.1</phrase>. 
       This Appendix specifies the <code>application/xquery+xml</code> media type,
       which is intended to be used for transmitting queries expressed in the
       XQueryX syntax.</p><!-- Changed "document" to "media type" per Liam Quin --><p diff="chg" at="2014-12-03">This media type registration is to allow for the deployment of
       XQueryX on the World Wide Web. </p><p>This document was prepared by members of the W3C XML Query Working
       Group.  Please send comments to public-qt-comments@w3.org,
       a public mailing list with archives at
       <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://lists.w3.org/Archives/Public/public-qt-comments</loc>. </p></div2><div2 id="xqueryx-mime-registration"><head>Registration of MIME Media Type <code>application/xquery+xml</code>
            </head><p>MIME media type name:  <code>application</code>
            </p><p>MIME subtype name:    <code>xquery+xml</code>
            </p><p>Required parameters:  none</p><p>Optional parameters: <code>charset</code>
            </p><p>This parameter has identical semantics to the
       <code>charset</code> parameter of the <code>application/xml</code>
       media type as specified in [RFC 3023].</p><div3 id="xqueryx-mime-encoding"><head>Encoding Considerations</head><p>By virtue of XSLT content being XML, it has the same considerations
      when sent as "<code>application/xquery+xml</code>" as does XML. 
      See [RFC 3023], section 3.2.</p></div3><div3 id="xqueryx-mime-security" diff="chg" at="bug29893"><head>Security Considerations</head><p>Queries written in XQuery may cause arbitrary URIs or IRIs to be dereferenced. 
           Therefore, the security issues of [RFC 3987] Section 8 should be considered. 
           In addition, the contents of resources identified by <code>file:</code> URIs can in
           some cases be accessed, processed and returned as results. 
           XQuery expressions can invoke any of the functions defined in
           <phrase diff="chg" at="2014-04-24">
                     <bibref ref="xpath-functions-31"/>
                  </phrase>.
           For example, the <code>fn:doc()</code> and <code>fn:doc-available()</code> functions  
           allow local filesystem probes as well as access to any URI-defined resource accessible 
           from the system evaluating the XQuery expression.

           <phrase diff="add" at="bug 30027">
           The <code>fn:transform()</code> function allows calls to
           URI-identified XSLT transformations which may in turn call
           external extension functions and access or write to the
           file system. The <code>fn:transform()</code> function
           should be sandboxed or disabled if untrusted queries are
           run.
           </phrase>
               </p><p>XQuery is a full declarative programming language, and supports
           user-defined functions, external function libraries (modules)
           referenced by URI, and system-specific "native" functions. </p><p>Arbitrary recursion is possible, as is arbitrarily large
           memory usage, and implementations may place limits on CPU and
           memory usage, as well as restricting access to system-defined functions. </p><p>
           The optional XQuery Update Facility allows XQuery expressions to
           create and update persistent data, potentially including writing
           to arbitrary locations on the local filesystem as well as to
           remote URIs. Untrusted queries should not be given write access
           to data.
        </p><p>Furthermore, because the XQuery language permits extensions, it is
           possible that <code>application/xquery+xml</code> may describe content 
           that has security implications beyond those described here. </p></div3><div3 id="xqueryx-mime-interoperability"><head>Interoperability Considerations</head><p>See <phrase diff="chg" at="2014-04-24">
                     <xspecref spec="XQ31" ref="id-conformance"/>
                  </phrase>. </p></div3><div3 id="xqueryx-mime-pubspec"><head>Published specification</head><p>This media type registration is for XQueryX documents as described
         by the <phrase diff="chg" at="2014-04-24">XQueryX 3.1 specification, which is located at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xqueryx-31/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xqueryx-31/</loc>
                  </phrase>. 
         It is also appropriate to use this media type with later versions of
         the XQueryX language. </p></div3><div3 id="xqueryx-mime-applications"><head>Applications That Use This Media Type</head><p>The public <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XQuery Web page</loc>
         lists more than two dozen implementations of the XQuery language,
	       both proprietary and open source.  Some of these are known to
         support XQueryX. </p><p>This new media type is being registered to allow for deployment
	       of XQueryX on the World Wide Web.</p><p>There is no experimental, vendor specific, or personal tree
         predecessor to "application/xquery+xml", reflecting the fact
         that no applications currently recognize it. This new type is
         being registered in order to allow for the expected deployment
         of <phrase diff="chg" at="2014-04-24">XQueryX 3.1</phrase>
         on the World Wide Web, as a first class XML application. </p></div3><div3 id="xqueryx-mime-additional"><head>Additional Information</head><div4 id="xqueryx-mime-recognizing"><head>Recognizing XQuery Files ("Magic Numbers")</head><p>Although no byte sequences can be depended on to consistently
           identify XQueryX, XQueryX documents will have the sequence
           "http://www.w3.org/2005/XQueryX" to identify the XQueryX
           namespace. 
           This sequence will normally be found in a namespace attribute
           of the first element in the document. </p></div4><div4 id="xqueryx-mime-extensions"><head>File Extensions</head><p>The most common file extension in use for XQueryX is
	      <code>.xqx</code>. </p></div4><div4 id="xqueryx-mime-macfiletype"><head>Macintosh File Type Code(s)</head><p>The appropriate Macintosh file type code is <code>TEXT</code>.</p></div4></div3><div3 id="xqueryx-mime-author"><head>Person and Email Address to Contact For Further Information</head><p>Jim Melton, Oracle Corp.,
          <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:jim.melton@oracle.com" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">jim.melton@oracle.com</loc>
               </p></div3><div3 id="xqueryx-mime-intended-usage"><head>Intended Usage</head><p>COMMON</p></div3><div3 id="xqueryx-mime-restrictions"><head>Restrictions on usage</head><p>The intended usage of this media type is for interchange
         of XQueryX expressions.</p></div3><div3 id="xqueryx-mime-owner"><head>Author/Change Controller</head><p>XQuery was produced by, and is maintained by, the World Wide Web
         Consortium's XML Query Working Group.  The W3C has change
         control over this specification. </p></div3><div3 id="xqueryx-mime-fragments"><head>Fragment Identifiers</head><p>For documents labeled as "<code>application/xquery+xml</code>",
         the fragment identifier notation is exactly that for
         "<code>application/xml</code>", as specified in [RFC 3023]. </p></div3></div2></div1><inform-div1 id="changelog"><head>Change log</head><p>This appendix lists the changes that have been made to this specification
         since the publication of the XQueryX 3.0 Recommendation on 24 April 2014. </p><div2 id="changelog_incompatibilities"><head>Incompatibilities</head><p diff="chg" at="2013-12-17">The
           Recommendation
           of
           21 March 2017,
           contains the following incompatibilities with XQueryX 3.0.
           The changes made to this document are described below. 
           The rationale for each change is explained in the corresponding Bugzilla database entry (if any). 
           The following table summarizes the changes that have been applied.
        </p><!-- Don't produce sections for documents that have not yet been published!

        <div3 id="changelog_incompat_PR" diff="add" at="2014-07-13">
          <head>Incompatibilities introduced during the Proposed Recommendation period</head>

        <ulist diff="chg" at="2014-07-13">

          <item diff="add" at="2014-07-13">
            <p>None.</p>
          </item>

        </ulist>

        </div3>

        <div3 id="changelog_incompat_CR" diff="add" at="2014-07-13">
          <head>Incompatibilities introduced during the Candidate Recommendation period</head>

        <ulist diff="chg" at="2014-07-13">

          <item diff="add" at="2014-07-13">
            <p>None.</p>
          </item>

        </ulist>

        </div3>

        <div3 id="changelog_incompat_LC" diff="add" at="2014-07-13">
          <head>Incompatibilities introduced during the Last Call period</head>

        <ulist diff="chg" at="2014-07-13">

          <item diff="add" at="2014-07-13">
            <p>None.</p>
          </item>

        </ulist>

        </div3>

Don't produce sections for documents that have not yet been published! --><div3 id="changelog_incompat_WD" diff="add" at="2014-07-13"><head>Incompatibilities introduced during the Working Draft period</head><ulist diff="chg" at="2014-07-13"><item diff="add" at="2014-07-13"><p>None.</p></item></ulist></div3><div3 id="changelog_incompat_preFPWD" diff="add" at="2014-07-13"><head>Incompatibilities introduced before publication of the First Public Working Draft</head><ulist diff="chg" at="2014-07-13"><item diff="add" at="2014-07-13"><p>None.</p></item></ulist></div3></div2><div2 id="changelog_substantive"><head>Substantive changes</head><p>In the
           Recommendation
           of
           21 March 2017,
           the following substantive changes have been made relative to XQueryX 3.0.
           The changes made to this document are described below. 
           The rationale for each change is explained in the corresponding Bugzilla database entry (if any). 
           The following table summarizes the changes that have been applied.
        </p><!-- Don't produce sections for documents that have not yet been published!

        <div3 id="changelog_substantive_PR" diff="add" at="2014-07-13">
          <head>Substantive changes introduced during the Proposed Recommendation period</head>

        <ulist diff="chg" at="2014-07-13">

          <item diff="add" at="2014-07-13">
            <p>None.</p>
          </item>

        </ulist>

        </div3>

        <div3 id="changelog_substantive_CR" diff="add" at="2014-07-13">
          <head>Substantive changes introduced during the Candidate Recommendation period</head>

        <ulist diff="chg" at="2014-07-13">

          <item diff="add" at="2014-07-13">
            <p>None.</p>
          </item>

        </ulist>

        </div3>

Don't produce sections for documents that have not yet been published! --><div3 id="changelog_substantive_LC" diff="add" at="2014-12-09"><head>Substantive changes introduced during the Last Call period</head><ulist><item><p>None.</p></item></ulist></div3><div3 id="changelog_substantive_WD" diff="add" at="2014-07-13"><head>Substantive changes introduced during the Working Draft period</head><ulist diff="chg" at="2014-07-13"><item diff="add" at="2014-07-11"><p>Added support for map tests (anyMapTest and typedMapTest) and array tests (anyArrayTest and typedArrayTest).
            (Affects <specref ref="Schema"/> and <specref ref="Stylesheet"/>.)</p></item><item diff="add" at="2014-07-13"><p>Modified definition of stepExpr to allow additional alternatives (besides "predicates") following the
            primaryExpr; the new alternatives include a mixed sequence of "predicate", "lookup", and "arrowPostfix".
            (Affects <specref ref="Schema"/> and <specref ref="Stylesheet"/>.)</p></item><item diff="add" at="2014-07-13"><p>Added support for XQuery 3.0 new features Lookup, UnaryLookup, and ArrowPostfix.
            This includes making UnaryLookup a new alternative of PrimaryExpr (in XQueryX, it becomes a new
            alternative of filterExpr).
            (Affects <specref ref="Schema"/> and <specref ref="Stylesheet"/>.)</p></item><item diff="add" at="2014-07-13"><p>Added support for XQuery 3.0 new features MapConstructor and ArrayConstructor
            (both SquareArrayConstructor and CurlyArrayConstructor).
            This includes making both of those new alternatives of PrimaryExpr
            (in XQueryX, they become new alternatives of filterExpr).
            (Affects <specref ref="Schema"/> and <specref ref="Stylesheet"/>.)</p></item><item diff="add" at="2014-07-16"><p>Added support for a new option ("*") to the alternatives for lookup (formerly mapLookup).
            (Affects <specref ref="Schema"/> and <specref ref="Stylesheet"/>.)</p></item></ulist></div3><div3 id="changelog_substantive_preFPWD" diff="add" at="2014-07-13"><head>Substantive changes introduced before publication of the First Public Working Draft</head><ulist diff="chg" at="2014-07-13"><item diff="add" at="2014-07-13"><p>None.</p></item></ulist></div3></div2><div2 id="changelog_editorial"><head>Minor and Editorial changes</head><p diff="chg" at="2013-12-17">In the
           Recommendation
           of
           21 March 2017,
           the following minor and editorial changes have been made relative to XQueryX 3.0.
           The changes made to this document are described below. 
           The rationale for each change is explained in the corresponding Bugzilla database entry (if any). 
           The following table summarizes the changes that have been applied.
        </p><!-- Don't produce sections for documents that have not yet been published!

        <div3 id="changelog_minor-editorial_PR" diff="add" at="2014-07-13">
          <head>Minor and Editorial changes introduced during the Proposed Recommendation period</head>

        <ulist diff="chg" at="2014-07-13">

          <item diff="add" at="2014-07-13">
            <p>None.</p>
          </item>

        </ulist>

        </div3>

        <div3 id="changelog_minor-editorial_CR" diff="add" at="2014-07-13">
          <head>Minor and Editorial introduced during the Candidate Recommendation period</head>

        <ulist diff="chg" at="2014-07-13">

          <item diff="add" at="2014-07-13">
            <p>None.</p>
          </item>

        </ulist>

        </div3>

Don't produce sections for documents that have not yet been published! --><div3 id="changelog_minor-editorial_LC" diff="add" at="2014-12-09"><head>Minor and Editorial introduced during the Last Call period</head><ulist><item><p>None.</p></item></ulist></div3><div3 id="changelog_minor-editorial_WD" diff="add" at="2014-07-13"><head>Minor and Editorial introduced during the Working Draft period</head><ulist diff="chg" at="2014-07-13"><item diff="add" at="2014-07-13"><p>Overhauled the manner in which <specref ref="changelog"/> is presented. </p></item></ulist></div3><div3 id="changelog_minor-editorial_preFPWD" diff="add" at="2014-07-13"><head>Minor and Editorial introduced before publication of the First Public Working Draft</head><ulist diff="chg" at="2014-07-13"><item diff="add" at="2014-07-13"><p>Updated several references, including a change from referencing XQueryX 1.0 to referencing XQueryX 3.0,
            and a change from referencing XQuery 3.0 to referencing XQuery 3.1. </p></item></ulist></div3></div2></inform-div1></back></spec>